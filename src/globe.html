<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth Globe</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #weatherInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 200px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="weatherInfo">Loading weather...</div>
    <script>
        let scene, camera, renderer, globe, controls, trajectoryLine, launchMarker;

        function init() {
            try {
                // Scene
                scene = new THREE.Scene();

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 1.8; // Closer to make globe larger

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0); // Transparent background
                document.body.appendChild(renderer.domElement);

                // Globe geometry
                const geometry = new THREE.SphereGeometry(1, 64, 64);

                // Earth texture - try multiple paths
                const textureLoader = new THREE.TextureLoader();

                textureLoader.load(
                    '../assets/images/earth_texture.jpg',
                    function(texture) {
                        // Material
                        const material = new THREE.MeshPhongMaterial({
                            map: texture,
                            transparent: true,
                            opacity: 0.9
                        });

                        // Mesh
                        globe = new THREE.Mesh(geometry, material);
                        scene.add(globe);

                        // Cloud layer
                        const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
                        textureLoader.load(
                            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
                            function(cloudTexture) {
                                const cloudMaterial = new THREE.MeshLambertMaterial({
                                    map: cloudTexture,
                                    transparent: true,
                                    opacity: 0.8,
                                    alphaMap: cloudTexture
                                });
                                const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                                clouds.name = 'clouds';
                                globe.add(clouds);
                                console.log("Cloud layer added");
                            },
                            undefined,
                            function(error) {
                                console.error("Error loading cloud texture:", error);
                            }
                        );

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(1, 1, 1);
                        scene.add(directionalLight);

                        // Start animation
                        animate();
                    },
                    function(progress) {
                        // Loading progress
                    },
                    function(error) {
                        console.error("Error loading texture:", error);
                        // Fallback: create globe without texture
                        const material = new THREE.MeshPhongMaterial({
                            color: 0x2233ff,
                            transparent: true,
                            opacity: 0.9
                        });

                        globe = new THREE.Mesh(geometry, material);
                        scene.add(globe);

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(1, 1, 1);
                        scene.add(directionalLight);

                        animate();
                    }
                );

                // Controls
                controls = {
                    autoRotate: true,
                    autoRotateSpeed: 0.3,
                    enableZoom: true,
                    enablePan: false,
                    enableRotate: true
                };

                // Handle window resize
                window.addEventListener('resize', onWindowResize, false);
                console.log("Event listeners added");

            } catch (error) {
                console.error("Error during initialization:", error);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (globe && controls && controls.autoRotate) {
                globe.rotation.y += controls.autoRotateSpeed * 0.01;
            }

            // Rotate clouds slower than the globe
            const clouds = scene.getObjectByName('clouds');
            if (clouds) {
                clouds.rotation.y += 0.0005;
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        function updateWeather(weatherData) {
            const weatherDiv = document.getElementById('weatherInfo');
            if (weatherData) {
                weatherDiv.innerHTML = '<strong>Weather at ' + weatherData.location + '</strong><br>' +
                    'Temp: ' + weatherData.temp + 'Â°C<br>' +
                    'Condition: ' + weatherData.description + '<br>' +
                    'Wind: ' + weatherData.wind_speed + ' m/s';
            } else {
                weatherDiv.innerHTML = 'Weather data unavailable';
            }
            }

        function updateTrajectory(trajectoryData) {            // Remove existing trajectory line
            if (trajectoryLine) {
                if (globe) globe.remove(trajectoryLine);
                scene.remove(trajectoryLine);
                trajectoryLine.geometry.dispose();
                trajectoryLine.material.dispose();
                console.log("Removed existing trajectory");
            }

            // Remove existing launch marker
            if (launchMarker) {
                if (globe) globe.remove(launchMarker);
                scene.remove(launchMarker);
                launchMarker.geometry.dispose();
                launchMarker.material.dispose();
                console.log("Removed existing launch marker");
            }

            if (!trajectoryData || !trajectoryData.trajectory || trajectoryData.trajectory.length < 2) {
                console.log("No valid trajectory data");
                return;
            }

            console.log("Creating trajectory with", trajectoryData.trajectory.length, "points");
            console.log("Orbit path present:", !!trajectoryData.orbit_path, "with", trajectoryData.orbit_path ? trajectoryData.orbit_path.length : 0, "points");

            try {
                // Create trajectory points from the curved lat/lon data
                const points = [];

                trajectoryData.trajectory.forEach((point, index) => {
                    // Convert lat/lon to 3D coordinates on sphere with subtle arc height
                    const phi = (90 - point.lat) * (Math.PI / 180);
                    const theta = (point.lon + 180) * (Math.PI / 180);

                    // Add subtle height variation for visual effect
                    const progress = index / (trajectoryData.trajectory.length - 1);
                    const baseRadius = 1.01; // Slightly above surface
                    const arcHeight = 0.03 * Math.sin(progress * Math.PI); // Very subtle arc
                    const radius = baseRadius + arcHeight;

                    const x = -(radius * Math.sin(phi) * Math.cos(theta));
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    const y = radius * Math.cos(phi);

                    points.push(new THREE.Vector3(x, y, z));
                });

                console.log("Created", points.length, "3D points");

                // Create trajectory geometry and material
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0xff4444,
                    linewidth: 3,
                    transparent: true,
                    opacity: 0.8
                });

                // Create trajectory line
                trajectoryLine = new THREE.Line(geometry, material);

                // Add trajectory as a child of the globe so it rotates with it
                if (globe) {
                    globe.add(trajectoryLine);
                    console.log("Trajectory line added as child of globe");
                } else {
                    scene.add(trajectoryLine);
                    console.log("Trajectory line added to scene (globe not available)");
                }

                // Add launch site marker
                if (trajectoryData.launch_site) {
                    const launchPoint = trajectoryData.trajectory[0];
                    const phi = (90 - launchPoint.lat) * (Math.PI / 180);
                    const theta = (launchPoint.lon + 180) * (Math.PI / 180);
                    const radius = 1.02;

                    const x = -(radius * Math.sin(phi) * Math.cos(theta));
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    const y = radius * Math.cos(phi);

                    const markerGeometry = new THREE.SphereGeometry(0.01, 8, 8);
                    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                    launchMarker = new THREE.Mesh(markerGeometry, markerMaterial);
                    launchMarker.position.set(x, y, z);

                    // Add marker as child of globe too
                    if (globe) {
                        globe.add(launchMarker);
                        console.log("Launch site marker added as child of globe");
                    } else {
                        scene.add(launchMarker);
                        console.log("Launch site marker added to scene");
                    }
                }

                // Remove previous orbit line if it exists
                if (window.currentOrbitLine) {
                    if (globe) globe.remove(window.currentOrbitLine);
                    scene.remove(window.currentOrbitLine);
                    window.currentOrbitLine.geometry.dispose();
                    window.currentOrbitLine.material.dispose();
                    window.currentOrbitLine = null;
                    console.log("Removed existing orbit line");
                }

                // Draw orbital path if present
                if (trajectoryData.orbit_path && trajectoryData.orbit_path.length > 2) {
                    console.log("Rendering orbit path with", trajectoryData.orbit_path.length, "points");

                    const orbitPoints = [];
                    trajectoryData.orbit_path.forEach((point, index) => {
                        const phi = (90 - point.lat) * (Math.PI / 180);
                        const theta = (point.lon + 180) * (Math.PI / 180);
                        // Keep orbit at a slightly higher radius for visibility
                        const radius = 1.04;
                        const x = -(radius * Math.sin(phi) * Math.cos(theta));
                        const z = radius * Math.sin(phi) * Math.sin(theta);
                        const y = radius * Math.cos(phi);
                        orbitPoints.push(new THREE.Vector3(x, y, z));
                    });
                    // Use LineSegments for dashed effect
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                    const orbitMaterial = new THREE.LineDashedMaterial({
                        color: 0x00ffff,
                        linewidth: 2,
                        dashSize: 0.03,
                        gapSize: 0.02,
                        transparent: true,
                        opacity: 0.7
                    });
                    const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                    orbitLine.computeLineDistances();
                    if (globe) {
                        globe.add(orbitLine);
                    } else {
                        scene.add(orbitLine);
                    }
                    window.currentOrbitLine = orbitLine;
                    console.log("Orbit line added");
                }

                // Force a render
                renderer.render(scene, camera);
                console.log("Forced render");

            } catch (error) {
                console.error("Error in updateTrajectory:", error);
            }
        }

        // Initialize and start animation
        console.log("Starting initialization...");
        init();

        // Expose functions to Qt
        window.updateTrajectory = updateTrajectory;
        window.updateWeather = updateWeather;

        // Make globe interactive
        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        document.addEventListener('mousemove', (event) => {
            if (!isMouseDown) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            globe.rotation.y += deltaX * 0.01;
            globe.rotation.x += deltaY * 0.01;

            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Touch support for mobile
        document.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                isMouseDown = true;
                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
        });

        document.addEventListener('touchmove', (event) => {
            if (!isMouseDown || event.touches.length !== 1) return;

            event.preventDefault();

            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;

            globe.rotation.y += deltaX * 0.01;
            globe.rotation.x += deltaY * 0.01;

            previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        });

        document.addEventListener('touchend', () => {
            isMouseDown = false;
        });
    </script>
</body>
</html>