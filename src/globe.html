<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth Globe</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
            color: white;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #playPauseBtn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            /* Move to bottom left */
            background: transparent;
            /* Graph button style: transparent */
            color: rgba(255, 255, 255, 0.7);
            /* Subtle white */
            border: none;
            /* No border */
            padding: 8px;
            font-size: 18px;
            /* Slightly larger icon */
            cursor: pointer;
            transition: color 0.2s;
            z-index: 1000;
        }

        #playPauseBtn:hover {
            background: transparent;
            color: white;
            /* Bright white on hover */
        }

        /* Light Mode Styles */
        body.light-mode #playPauseBtn {
            color: rgba(0, 0, 0, 0.7);
        }

        body.light-mode #playPauseBtn:hover {
            color: black;
        }
    </style>
    <script>
        // Lightweight loader that ensures THREE is available even if we started offline.
        // We avoid hard-failing when there's no network at boot and retry when it comes back.
        (function () {
            var attempts = 0;
            function injectThree(onReady) {
                if (window.THREE) { onReady && onReady(); return; }
                attempts++;
                try {
                    var s = document.createElement('script');
                    // Alternate between local and CDN every 2 attempts
                    if (attempts % 2 === 1) {
                        s.src = 'three.min.js';
                    } else {
                        s.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                    }
                    s.async = true;
                    s.onload = function () { onReady && onReady(); };
                    s.onerror = function () {
                        // Retry shortly; also wait for online event
                        var delay = attempts > 5 ? 10000 : 4000;
                        setTimeout(function () { injectThree(onReady); }, delay);
                    };
                    document.head.appendChild(s);
                } catch (e) {
                    setTimeout(function () { injectThree(onReady); }, 4000);
                }
            }
            // Expose a boot function used at the bottom of the file
            window.__ensureThreeAndBoot = function (cb) {
                if (window.THREE) { cb && cb(); return; }
                injectThree(cb);
                // Also try again when network comes online
                window.addEventListener('online', function () { injectThree(cb); }, { once: true });
            };
        })();
    </script>
</head>

<body>
    <button id="playPauseBtn"><i class="fas fa-play"></i></button>
    <script>
        let scene, camera, renderer, globe, controls, trajectoryGroup, launchMarker;
        let momentumX = 0, momentumY = 0;
        let isInMomentum = false;
        let lastTime = Date.now();
        let isAutoRotatePaused = true; // Start paused
        // Distinguish between user-initiated pause and system-initiated pause (e.g., during app/network events)
        let userPaused = true; // Start paused
        let systemPaused = false;
        let pendingSystemResume = false; // set when resume is requested during active interaction
        // Explicit auto spin enable independent of OrbitControls (more robust on Qt WebEngine)
        let autoSpinEnabled = true;
        // Track if the user is actively interacting (mouse down or any touch contact)
        // This is used to prevent auto-rotation from starting/resuming while touching.
        let userInteracting = false;
        // Track active pointer contacts (helps on Linux/Qt where pointer events may be used)
        let activePointers = 0;
        // Track gesture mode to avoid mixing pinch and drag states
        // Values: 'none' | 'drag' | 'pinch'
        let touchMode = 'none';
        // Track last deltas to decide whether to start momentum on release
        let lastDeltaX = 0, lastDeltaY = 0;
        let lastMoveTimeMs = 0;
        // Drag deadzone and pinch tracking
        const DRAG_DEADZONE_PX = 8;           // ignore tiny movements
        const RECENT_MS_THRESHOLD = 110;      // last movement must be recent
        const MIN_RELEASE_VELOCITY = 0.002;   // minimum velocity to start inertia
        let cumulativeDragDistance = 0;       // reset per-drag
        let hadPinchSinceLastDrag = false;    // cancels inertia if pinch occurred

        // Short-window velocity averaging to avoid "opposite recoil"
        const VELOCITY_WINDOW_MS = 140;       // average last ~140 ms of motion
        let recentMoves = [];                 // entries: { t, dt, dxAdj, dy }

        function resetRecentMoves() { recentMoves = []; }
        function pushRecentMove(dx, dy, yDirection, dt, now) {
            if (!isFinite(dt) || dt <= 0) return;
            const entry = {
                t: now,
                dt: dt,
                dxAdj: dx * yDirection,
                dy: dy
            };
            recentMoves.push(entry);
            // Trim old entries beyond window
            const cutoff = now - VELOCITY_WINDOW_MS;
            while (recentMoves.length && recentMoves[0].t < cutoff) {
                recentMoves.shift();
            }
            // Keep list reasonably small (safety cap)
            if (recentMoves.length > 20) recentMoves.splice(0, recentMoves.length - 20);
        }
        function getAveragedVelocity() {
            if (!recentMoves.length) return { vx: 0, vy: 0, mag: 0 };
            let sumDx = 0, sumDy = 0, sumDt = 0;
            for (const m of recentMoves) {
                sumDx += m.dxAdj;
                sumDy += m.dy;
                sumDt += m.dt;
            }
            if (sumDt <= 0) return { vx: 0, vy: 0, mag: 0 };
            // Scale to match previous tuning (0.1 factor used before)
            const vx = (sumDx / sumDt) * 0.1;
            const vy = (sumDy / sumDt) * 0.1;
            const mag = Math.abs(vx) + Math.abs(vy);
            return { vx, vy, mag };
        }

        // Zoom parameters
        const DEFAULT_CAMERA_Z = 1.8;      // Existing default distance (keep as farthest zoom-out)
        const CAMERA_MIN_Z = 1.1;          // How close you can zoom in (tweak if needed)
        const CAMERA_MAX_Z = DEFAULT_CAMERA_Z; // Clamp max to current default
        const ZOOM_STEP = 0.1;             // Base step for wheel zoom adjustments
        let pinchStartDistance = null;
        let pinchStartZ = null;

        function init() {
            try {
                // Scene
                scene = new THREE.Scene();

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = DEFAULT_CAMERA_Z; // Closer to make globe larger

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(window.devicePixelRatio); // Sharpness on high-DPI screens
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0); // Transparent background
                document.body.appendChild(renderer.domElement);
                // Allow us to prevent default touch gestures for custom pinch zoom
                renderer.domElement.style.touchAction = 'none';

                // Globe geometry
                const geometry = new THREE.SphereGeometry(1, 64, 64);

                // Earth texture - try multiple paths
                const textureLoader = new THREE.TextureLoader();

                function loadEarthTexture(hdPath, sdPath, onComplete) {
                    // Optimized Tiled HD loading (bypasses Pi 4096px hardware limit)
                    // Configurable grid: 2x1 (Med), 4x2 (High), 6x3 (Ultra)
                    // Make sure these match the output of tools/tile_globe_texture.py
                    const tilesX = 4;
                    const tilesY = 2;
                    const firstTilePath = '../assets/images/tiles/tile_0_0.jpg';

                    textureLoader.load(firstTilePath,
                        function (firstTex) {
                            console.log("Found tiled textures, loading set...");
                            const tileTextures = new Array(tilesX * tilesY);
                            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                            firstTex.anisotropy = maxAnisotropy;
                            tileTextures[0] = firstTex;

                            let loadedCount = 1;
                            const totalTiles = tilesX * tilesY;

                            if (totalTiles === 1) {
                                onComplete(tileTextures, tilesX, tilesY);
                                return;
                            }

                            for (let i = 1; i < totalTiles; i++) {
                                const tx = i % tilesX;
                                const ty = Math.floor(i / tilesX);
                                const tilePath = `../assets/images/tiles/tile_${tx}_${ty}.jpg`;

                                textureLoader.load(tilePath,
                                    function (tex) {
                                        tex.anisotropy = maxAnisotropy;
                                        tileTextures[i] = tex;
                                        loadedCount++;
                                        if (loadedCount === totalTiles) {
                                            onComplete(tileTextures, tilesX, tilesY);
                                        }
                                    },
                                    undefined,
                                    function () {
                                        console.warn("Failed to load some tiles, falling back to single HD");
                                        loadSingleHD();
                                    }
                                );
                            }
                        },
                        undefined,
                        function () {
                            console.log("Tiled textures not found, trying single HD...");
                            loadSingleHD();
                        }
                    );

                    function loadSingleHD() {
                        // Try HD
                        textureLoader.load(hdPath,
                            function (texture) {
                                console.log("Loaded HD Earth texture");
                                const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                                texture.anisotropy = maxAnisotropy;
                                onComplete(texture);
                            },
                            undefined,
                            function (err) {
                                console.log("HD texture not found, trying SD...");
                                // Try SD
                                textureLoader.load(sdPath,
                                    function (texture) {
                                        console.log("Loaded SD Earth texture");
                                        const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                                        texture.anisotropy = maxAnisotropy;
                                        onComplete(texture);
                                    },
                                    undefined,
                                    function (err2) {
                                        console.log("SD texture not found, falling back to procedural");
                                        onComplete(null);
                                    }
                                );
                            }
                        );
                    }
                }

                loadEarthTexture(
                    '../assets/images/earth_texture_hd.jpg',
                    '../assets/images/earth_texture.jpg',
                    function (texture, tX, tY) {
                        if (Array.isArray(texture)) {
                            // Tiled mode
                            globe = new THREE.Group();
                            const tilesX = tX;
                            const tilesY = tY;

                            for (let y = 0; y < tilesY; y++) {
                                for (let x = 0; x < tilesX; x++) {
                                    const phiStart = (x / tilesX) * Math.PI * 2;
                                    const phiLength = (1 / tilesX) * Math.PI * 2;
                                    const thetaStart = (y / tilesY) * Math.PI;
                                    const thetaLength = (1 / tilesY) * Math.PI;

                                    const tileGeom = new THREE.SphereGeometry(1, 64 / tilesX, 64 / tilesY, phiStart, phiLength, thetaStart, thetaLength);
                                    const tileMat = new THREE.MeshPhongMaterial({
                                        map: texture[y * tilesX + x],
                                        transparent: true,
                                        opacity: 0.9
                                    });
                                    const tileMesh = new THREE.Mesh(tileGeom, tileMat);
                                    globe.add(tileMesh);
                                }
                            }
                        } else {
                            // Single texture mode
                            let material;
                            if (texture) {
                                material = new THREE.MeshPhongMaterial({
                                    map: texture,
                                    transparent: true,
                                    opacity: 0.9
                                });
                            } else {
                                // Fallback: create globe without texture
                                material = new THREE.MeshPhongMaterial({
                                    color: 0x2233ff,
                                    transparent: true,
                                    opacity: 0.9
                                });
                            }
                            globe = new THREE.Mesh(geometry, material);
                        }

                        scene.add(globe);

                        // Set initial tilt for better orbit visibility
                        globe.rotation.x = 0.6;
                        // Focus on US (approx 0.5 radians: 4.7 was Africa, increasing moves West)
                        globe.rotation.y = 0.5;

                        // Cloud layer (Shader-based)
                        const cloudGeometry = new THREE.SphereGeometry(1.01, 80, 80);
                        const cloudVertexShader = `
                            precision mediump float;
                            varying vec2 vUv;
                            varying vec3 vNormal;
                            varying vec3 vViewPosition;
                            void main() {
                                vUv = uv;
                                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                                vNormal = normalize(normalMatrix * normal);
                                vViewPosition = -mvPosition.xyz;
                                gl_Position = projectionMatrix * mvPosition;
                            }
                        `;
                        const cloudFragmentShader = `
                            precision mediump float;
                            uniform sampler2D cloudTexture;
                            uniform float time;
                            uniform bool hasTexture;
                            varying vec2 vUv;
                            varying vec3 vNormal;
                            varying vec3 vViewPosition;

                            // 2D Noise function for convection/swirl effect
                            vec2 hash(vec2 p) {
                                p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
                                return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
                            }

                            float noise(vec2 p) {
                                const float K1 = 0.366025404; // (sqrt(3)-1)/2;
                                const float K2 = 0.211324865; // (3-sqrt(3))/6;
                                vec2 i = floor(p + (p.x + p.y) * K1);
                                vec2 a = p - i + (i.x + i.y) * K2;
                                vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                                vec2 b = a - o + K2;
                                vec2 c = a - 1.0 + 2.0 * K2;
                                vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
                                vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));
                                return dot(n, vec3(70.0));
                            }

                            // Optimized multi-octave noise for Pi (fBm)
                            float fbm(vec2 p) {
                                float f = 0.0;
                                float amp = 0.5;
                                for (int i = 0; i < 6; i++) {
                                    f += amp * noise(p);
                                    p *= 2.1;
                                    amp *= 0.48;
                                }
                                return f;
                            }

                            void main() {
                                // Multi-scale distortion for organic movement
                                float n1 = noise(vUv * 4.0 + time * 0.04);
                                float n2 = noise(vUv * 8.0 - time * 0.07);
                                // Micro-swirls for high-resolution texture feel
                                float n3 = noise(vUv * 16.0 + time * 0.1);
                                vec2 distortedUv = vUv + vec2(n1 * 0.03 + n3 * 0.005, n2 * 0.02);
                                
                                vec4 texColor;
                                vec4 texColor2;
                                
                                if (hasTexture) {
                                    texColor = texture2D(cloudTexture, distortedUv);
                                    // High-frequency detail injection for texture mode
                                    float detail = fbm(vUv * 25.0 - time * 0.05) * 0.25;
                                    texColor.a *= (1.0 + detail);
                                    
                                    float n3 = noise(vUv * 6.0 - time * 0.05);
                                    texColor2 = texture2D(cloudTexture, vUv + vec2(n3 * 0.015, 0.0));
                                } else {
                            // High-detail procedural fallback using fBm
                                    // Layer 1: Large slow structures (low freq, high amp)
                                    float layer1 = fbm(vUv * 4.8 + time * 0.025) * 0.65 + 0.35;
                                    // Layer 2: Medium faster wisps (med freq, med amp)
                                    float layer2 = fbm(vUv * 10.5 - time * 0.07) * 0.55 + 0.45;
                                    // Layer 3: High-freq detail (micro-noise)
                                    float layer3 = fbm(vUv * 45.0 + time * 0.1) * 0.45 + 0.55;
                                    
                                    // Complex blending for organic structure
                                    float combined = mix(layer1, layer2, 0.45);
                                    combined = combined * 0.6 + layer3 * 0.4;
                                    
                                    // Dynamic "sculpting" of cloud edges for high-res look
                                    float cloudAlpha = smoothstep(0.4, 0.72, combined);
                                    
                                    // Secondary detail for "fluffiness" and internal structure
                                    float detail = fbm(vUv * 30.0 + time * 0.04);
                                    cloudAlpha += detail * 0.2 * cloudAlpha;
                                    
                                    vec3 cloudColor = vec3(1.0, 1.0, 1.0);
                                    
                                    // Add "shadow" effect for depth (Simulated lighting)
                                    float shadow = fbm(vUv * 6.0 + time * 0.04 + 0.15);
                                    cloudColor *= (0.8 + 0.2 * shadow);
                                    
                                    texColor = vec4(cloudColor, cloudAlpha * 0.95);
                                    
                                    // Second wispier layer for depth and atmospheric haze
                                    float wisp = fbm(vUv * 18.0 + time * 0.05) * 0.5 + 0.5;
                                    wisp = smoothstep(0.4, 0.88, wisp);
                                    texColor2 = vec4(cloudColor, wisp * 0.45);
                                }
                                
                                vec4 finalColor = mix(texColor, texColor2, 0.3);
                                if (hasTexture) {
                                    finalColor.a *= 0.8; 
                                }

                                // Fresnel rim effect for atmosphere-like clouds
                                float fresnel = pow(1.0 - max(dot(normalize(vNormal), normalize(vViewPosition)), 0.0), 3.0);
                                finalColor.a *= (0.8 + fresnel * 0.4);
                                
                                gl_FragColor = finalColor;
                            }
                        `;

                        const cloudUniforms = {
                            cloudTexture: { value: null },
                            time: { value: 0.0 },
                            hasTexture: { value: false }
                        };

                        const cloudMaterial = new THREE.ShaderMaterial({
                            uniforms: cloudUniforms,
                            vertexShader: cloudVertexShader,
                            fragmentShader: cloudFragmentShader,
                            transparent: true,
                            depthWrite: false // Good for transparency layers
                        });

                        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                        clouds.name = 'clouds';
                        globe.add(clouds);
                        
                        // Debug log for cloud creation
                        console.log("Cloud layer created and added to globe");

                        function loadCloudTexture() {
                            const cloudSources = [
                                '../assets/images/earth_clouds_1024.png',
                                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
                                'https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_clouds_1024.png'
                            ];

                            let sourceIndex = 0;

                            function tryNext() {
                                if (sourceIndex >= cloudSources.length) {
                                    console.warn("All cloud texture sources failed, using procedural fallback");
                                    cloudUniforms.hasTexture.value = false;
                                    cloudMaterial.needsUpdate = true;
                                    return;
                                }

                                const src = cloudSources[sourceIndex];
                                console.log("Attempting to load cloud texture from:", src);
                                textureLoader.load(
                                    src,
                                    function (cloudTexture) {
                                        cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;
                                        cloudUniforms.cloudTexture.value = cloudTexture;
                                        cloudUniforms.hasTexture.value = true;
                                        cloudMaterial.needsUpdate = true;
                                        console.log("Cloud layer texture loaded successfully from:", src);
                                    },
                                    undefined,
                                    function (error) {
                                        console.warn("Failed to load cloud texture from:", src);
                                        sourceIndex++;
                                        tryNext();
                                    }
                                );
                            }

                            tryNext();
                        }

                        loadCloudTexture();

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(1, 1, 1);
                        scene.add(directionalLight);

                        // Start animation
                        animate();
                    }
                );

                // Controls
                controls = {
                    autoRotate: true,
                    autoRotateSpeed: -0.3,
                    enableZoom: true,
                    enablePan: false,
                    enableRotate: true
                };

                // Handle window resize
                window.addEventListener('resize', onWindowResize, false);
                // Mouse wheel zoom (clamped so you can't zoom out past default)
                renderer.domElement.addEventListener('wheel', onWheelZoom, { passive: false });
                // Touch pinch zoom support
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                console.log("Event listeners added");

                // Pointer event fallbacks (Linux/Qt WebEngine often routes touch via pointer events)
                // We only count non-mouse pointers here to avoid double-handling regular mouse drags.
                // Moving these into init ensures renderer.domElement is available safely.
                renderer.domElement.addEventListener('pointerdown', (e) => {
                    if (e && e.pointerType && e.pointerType !== 'mouse') {
                        activePointers++;
                        userInteracting = true;
                    }
                });
                document.addEventListener('pointerup', (e) => {
                    if (e && e.pointerType && e.pointerType !== 'mouse') {
                        activePointers = Math.max(0, activePointers - 1);
                        if (activePointers === 0 && !isMouseDown) {
                            userInteracting = false;
                        }
                    }
                });
                document.addEventListener('pointercancel', (e) => {
                    if (e && e.pointerType && e.pointerType !== 'mouse') {
                        activePointers = Math.max(0, activePointers - 1);
                        if (activePointers === 0 && !isMouseDown) {
                            userInteracting = false;
                        }
                    }
                });

                // Disable in-page context menu (right-click/long-press)
                try { document.addEventListener('contextmenu', function (e) { e.preventDefault(); }, { passive: false }); } catch (_e) { }

            } catch (error) {
                console.error("Error during initialization:", error);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function clampCameraZ(z) {
            return Math.max(CAMERA_MIN_Z, Math.min(CAMERA_MAX_Z, z));
        }

        function onWheelZoom(event) {
            // Prevent page/system scrolling
            event.preventDefault();
            if (!camera) return;
            // Normalize wheel delta: negative => zoom in; positive => zoom out
            const delta = Math.sign(event.deltaY);
            let newZ = camera.position.z + (delta * ZOOM_STEP);
            newZ = clampCameraZ(newZ);
            camera.position.z = newZ;
        }

        function clampRotationX() {
            // Avoid flipping the globe which can invert drag directions
            const maxTilt = Math.PI / 2 - 0.05; // small margin from 90Â°
            if (!globe) return;
            if (globe.rotation.x > maxTilt) globe.rotation.x = maxTilt;
            if (globe.rotation.x < -maxTilt) globe.rotation.x = -maxTilt;
        }

        function distanceBetweenTouches(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.hypot(dx, dy);
        }

        function onTouchStart(event) {
            if (event.touches && event.touches.length === 2) {
                event.preventDefault();
                pinchStartDistance = distanceBetweenTouches(event.touches[0], event.touches[1]);
                pinchStartZ = camera ? camera.position.z : null;
                // Enter pinch mode and cancel any drag momentum state
                touchMode = 'pinch';
                isInMomentum = false;
                momentumX = 0; momentumY = 0;
                // Ensure drag state is not considered active
                isMouseDown = false;
                userInteracting = true;
            }
        }

        function onTouchMove(event) {
            if (event.touches && event.touches.length === 2 && pinchStartDistance && pinchStartZ != null) {
                event.preventDefault();
                const currentDistance = distanceBetweenTouches(event.touches[0], event.touches[1]);
                if (currentDistance > 0) {
                    // Ratio > 1 means fingers moved apart (zoom in)
                    const ratio = pinchStartDistance / currentDistance;
                    // Map ratio to z change around the start z
                    let targetZ = pinchStartZ * ratio;
                    // Ease the effect to avoid too aggressive zooming
                    targetZ = pinchStartZ + (targetZ - pinchStartZ) * 0.5;
                    camera.position.z = clampCameraZ(targetZ);
                }
            }
        }

        function onTouchEnd(event) {
            if (!event.touches || event.touches.length < 2) {
                pinchStartDistance = null;
                pinchStartZ = null;
                // Leave pinch mode; do not start momentum here (handled in document touchend for drag)
                if (touchMode === 'pinch' && (!event.touches || event.touches.length === 0)) {
                    touchMode = 'none';
                }
                if (!event.touches || event.touches.length === 0) {
                    userInteracting = false;
                }
            }
        }

        let __lastRenderTs = performance.now();
        let __lastResumeLogTs = 0;
        let __startTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const absoluteTime = (now - __startTime) / 1000.0;

            // Optimization: Skip all processing if system is paused and no interaction is happening
            if (systemPaused && !userInteracting && !isInMomentum) {
                // Still update time for clouds so they don't jump when resuming, 
                // but we aren't rendering anyway so it's just a variable update.
                return;
            }

            if (globe) {
                if (isInMomentum) {
                    // Apply momentum directly in the same frame of reference it was recorded
                    // (we bake orientation into momentum at capture time to avoid post-release flips)
                    globe.rotation.y += momentumX;
                    if (!window.__userRotOffset) window.__userRotOffset = 0;
                    window.__userRotOffset += momentumX;
                    
                    globe.rotation.x += momentumY;
                    clampRotationX();

                    // Decay momentum
                    // Slightly stronger damping to reduce perceived recoil
                    momentumX *= 0.93; // Friction/damping
                    momentumY *= 0.93;

                    // Check if momentum is low enough to return to auto-rotation
                    if (Math.abs(momentumX) < 0.0001 && Math.abs(momentumY) < 0.0001) {
                        isInMomentum = false;
                        momentumX = 0;
                        momentumY = 0;
                    }
                } else if (autoSpinEnabled && !userPaused && !systemPaused && !userInteracting) {
                    // Normal auto-rotation (decoupled from OrbitControls)
                    const baseSpeed = (controls && typeof controls.autoRotateSpeed === 'number') ? controls.autoRotateSpeed : 2.0;
                    // Use a separate base for auto-rotation to allow interaction to "offset" it
                    if (!window.__autoRotBase) window.__autoRotBase = 0;
                    window.__autoRotBase += baseSpeed * 0.01;
                    globe.rotation.y = window.__autoRotBase + (window.__userRotOffset || 0);
                }
            }

            // Rotate clouds slower than the globe
            const clouds = scene.getObjectByName('clouds');
            if (clouds) {
                // Cloud rotation can stay relative or use absolute time for perfect consistency
                clouds.rotation.y = absoluteTime * 0.05; 
                if (clouds.material && clouds.material.uniforms && clouds.material.uniforms.time) {
                    clouds.material.uniforms.time.value = absoluteTime;
                }
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }

            // Track last render timestamp for watchdog
            __lastRenderTs = now;
            
            // Periodically log animation status (every 5 seconds)
            if (now - __lastResumeLogTs > 5000) {
                console.log(`[globe] Animating: time=${absoluteTime.toFixed(2)}, systemPaused=${systemPaused}, userInteracting=${userInteracting}`);
                __lastResumeLogTs = now;
            }
        }

        function updateTrajectory(trajectoryData) {
            if (!renderer || !scene || !camera) {
                console.warn("updateTrajectory called before webgl components were ready");
                return;
            }
            // Remove existing trajectory group (which contains core and glow lines)
            if (trajectoryGroup) {
                if (globe) globe.remove(trajectoryGroup);
                scene.remove(trajectoryGroup);
                trajectoryGroup.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                trajectoryGroup = null;
                console.log("Removed existing trajectory group");
            }

            // Remove existing launch marker
            if (launchMarker) {
                if (globe) globe.remove(launchMarker);
                scene.remove(launchMarker);
                launchMarker.geometry.dispose();
                launchMarker.material.dispose();
                console.log("Removed existing launch marker");
            }

            if (!trajectoryData || !trajectoryData.trajectory || trajectoryData.trajectory.length < 2) {
                console.log("No valid trajectory data received:", trajectoryData);
                return;
            }

            console.log("Updating globe trajectory for mission:", trajectoryData.mission);
            console.log("Trajectory points:", trajectoryData.trajectory.length);
            console.log("Booster points:", trajectoryData.booster_trajectory ? trajectoryData.booster_trajectory.length : 0);
            console.log("Landing type:", trajectoryData.landing_type);

            try {
                // Create trajectory points from the curved lat/lon data
                const points = [];

                trajectoryData.trajectory.forEach((point, index) => {
                    // Convert lat/lon to 3D coordinates on sphere
                    const phi = (90 - point.lat) * (Math.PI / 180);
                    const theta = (point.lon + 180) * (Math.PI / 180);

                    // Use the radius provided by the backend, or fallback to 1.012
                    const radius = (typeof point.r === 'number') ? point.r : 1.012;

                    const x = -(radius * Math.sin(phi) * Math.cos(theta));
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    const y = radius * Math.cos(phi);

                    points.push(new THREE.Vector3(x, y, z));
                });

                // Create color gradient for the trajectory
                // REVERSED: From Electric Cyan (#00FFFF) at Start to Fiery Orange (#FF4500) at End
                const colors = [];
                const color1 = new THREE.Color(0x00FFFF); // Cyan
                const color2 = new THREE.Color(0xFF4500); // Orange

                trajectoryGroup = new THREE.Group();

                // 1. Trace Core Line using TubeGeometry for thickness
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeRadius = 0.0035; // Sharp main line
                const radialSegments = 8;
                const tubularSegments = points.length * 6; // smoothness
                const tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, radialSegments, false);

                // Apply vertex colors for gradient (Cyan -> Orange)
                const count = tubeGeometry.attributes.position.count;
                const colorArray = new Float32Array(count * 3);
                const uvs = tubeGeometry.attributes.uv;

                for (let i = 0; i < count; i++) {
                    const u = uvs.getX(i); // 0 at start, 1 at end
                    const c = color1.clone().lerp(color2, u);
                    colorArray[i * 3] = c.r;
                    colorArray[i * 3 + 1] = c.g;
                    colorArray[i * 3 + 2] = c.b;
                }

                tubeGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

                const tubeMaterial = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    side: THREE.DoubleSide
                });
                const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tubeMesh.renderOrder = 1;
                trajectoryGroup.add(tubeMesh);

                // 2. Glow effect (slightly larger tube, lower opacity, additive)
                const glowRadius = tubeRadius * 1.8;
                const glowGeometry = new THREE.TubeGeometry(curve, tubularSegments, glowRadius, radialSegments, false);
                glowGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3)); // reuse colors
                const glowMaterial = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false // Don't occlude the core
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.renderOrder = 2;
                trajectoryGroup.add(glowMesh);

                // 3. Booster Return Trajectory (Orange)
                if (trajectoryData.booster_trajectory && trajectoryData.booster_trajectory.length >= 2) {
                    console.log("Creating booster trajectory with", trajectoryData.booster_trajectory.length, "points");
                    const boosterPoints = [];
                    trajectoryData.booster_trajectory.forEach((point, index) => {
                        const phi = (90 - point.lat) * (Math.PI / 180);
                        const theta = (point.lon + 180) * (Math.PI / 180);

                        // Use radius from backend
                        const radius = (typeof point.r === 'number') ? point.r : 1.012;

                        const x = -(radius * Math.sin(phi) * Math.cos(theta));
                        const z = radius * Math.sin(phi) * Math.sin(theta);
                        const y = radius * Math.cos(phi);
                        boosterPoints.push(new THREE.Vector3(x, y, z));
                    });

                    const boosterCurve = new THREE.CatmullRomCurve3(boosterPoints);
                    const boosterTubeRadius = 0.005; // Thicker orange booster
                    const boosterTubeGeo = new THREE.TubeGeometry(boosterCurve, boosterPoints.length * 4, boosterTubeRadius, 8, false);
                    const boosterMat = new THREE.MeshBasicMaterial({
                        color: 0xFFA500, // Bright Orange
                        transparent: true,
                        opacity: 0.85,
                        side: THREE.DoubleSide
                    });
                    const boosterMesh = new THREE.Mesh(boosterTubeGeo, boosterMat);
                    boosterMesh.renderOrder = 3; // Ensure it's rendered over the main trajectory if they overlap
                    trajectoryGroup.add(boosterMesh);

                    // Booster Glow
                    const boosterGlowRadius = boosterTubeRadius * 2.0;
                    const boosterGlowGeo = new THREE.TubeGeometry(boosterCurve, boosterPoints.length * 4, boosterGlowRadius, 8, false);
                    const boosterGlowMat = new THREE.MeshBasicMaterial({
                        color: 0xFFA500,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const boosterGlowMesh = new THREE.Mesh(boosterGlowGeo, boosterGlowMat);
                    boosterGlowMesh.renderOrder = 4;
                    trajectoryGroup.add(boosterGlowMesh);

                    // 4. Separation Point Dot
                    if (typeof trajectoryData.sep_idx === 'number' && trajectoryData.sep_idx < boosterPoints.length) {
                        const sepPoint = boosterPoints[trajectoryData.sep_idx];
                        const dotRadius = 0.007;
                        const dotGeo = new THREE.SphereGeometry(dotRadius, 16, 16);
                        const dotMat = new THREE.MeshBasicMaterial({
                            color: 0xFFFFFF, // Bright White
                            transparent: true,
                            opacity: 0.9
                        });
                        const dot = new THREE.Mesh(dotGeo, dotMat);
                        dot.position.copy(sepPoint);
                        dot.renderOrder = 5;
                        trajectoryGroup.add(dot);

                        // Separation Dot Glow
                        const dotGlowGeo = new THREE.SphereGeometry(dotRadius * 1.8, 16, 16);
                        const dotGlowMat = new THREE.MeshBasicMaterial({
                            color: 0xFFFFFF,
                            transparent: true,
                            opacity: 0.4,
                            blending: THREE.AdditiveBlending,
                            depthWrite: false
                        });
                        const dotGlow = new THREE.Mesh(dotGlowGeo, dotGlowMat);
                        dotGlow.position.copy(sepPoint);
                        dotGlow.renderOrder = 6;
                        trajectoryGroup.add(dotGlow);
                        console.log("Added separation dot at index:", trajectoryData.sep_idx);
                    }

                    // Add a small landing pad marker if it's an ASDS or RTLS landing
                    const combinedInfo = ((trajectoryData.landing_type || '') + ' ' + (trajectoryData.landing_location || '')).toUpperCase();
                    const isASDS = combinedInfo.includes('ASDS') || 
                                 combinedInfo.includes('DRONE') ||
                                 combinedInfo.includes('SHIP') ||
                                 combinedInfo.includes('OCISLY') ||
                                 combinedInfo.includes('JRTI') ||
                                 combinedInfo.includes('ASOG') ||
                                 combinedInfo.includes('GRAVITAS') ||
                                 combinedInfo.includes('INSTRUCTIONS') ||
                                 combinedInfo.includes('STILL LOVE YOU');
                                 
                    const isRTLS = combinedInfo.includes('RTLS') ||
                                 combinedInfo.includes('LAUNCH SITE') ||
                                 combinedInfo.includes('LANDING ZONE') ||
                                 combinedInfo.includes('LZ-') ||
                                 combinedInfo.includes('CATCH') ||
                                 combinedInfo.includes('TOWER');

                    if (isASDS || isRTLS) {
                        const lastPoint = boosterPoints[boosterPoints.length - 1];
                        // Create a small circular pad
                        const padRadius = isASDS ? 0.008 : 0.006;
                        const padGeo = new THREE.CircleGeometry(padRadius, 16);
                        const padMat = new THREE.MeshBasicMaterial({ 
                            color: isASDS ? 0x00FFFF : 0x00FF00, // Cyan for droneship, Green for RTLS
                            transparent: true,
                            opacity: 0.8,
                            side: THREE.DoubleSide 
                        });
                        const pad = new THREE.Mesh(padGeo, padMat);
                        pad.position.copy(lastPoint);
                        // Orient pad to face away from earth center (up)
                        pad.lookAt(lastPoint.clone().multiplyScalar(2));
                        trajectoryGroup.add(pad);
                        
                        // Add a subtle glow to the pad
                        const padGlowGeo = new THREE.CircleGeometry(padRadius * 1.5, 16);
                        const padGlowMat = new THREE.MeshBasicMaterial({
                            color: isASDS ? 0x00FFFF : 0x00FF00,
                            transparent: true,
                            opacity: 0.3,
                            blending: THREE.AdditiveBlending,
                            side: THREE.DoubleSide
                        });
                        const padGlow = new THREE.Mesh(padGlowGeo, padGlowMat);
                        padGlow.position.copy(lastPoint);
                        padGlow.lookAt(lastPoint.clone().multiplyScalar(2));
                        trajectoryGroup.add(padGlow);
                    }
                }

                // Add trajectory group as a child of the globe
                if (globe) {
                    globe.add(trajectoryGroup);
                    console.log("Trajectory group added as child of globe");
                } else {
                    scene.add(trajectoryGroup);
                    console.log("Trajectory group added to scene (globe not available)");
                }

                // Removed launch site red dot marker per request; keep only the trajectory line

                // Remove previous orbit line/group if it exists
                if (window.currentOrbitLine) {
                    if (globe) globe.remove(window.currentOrbitLine);
                    scene.remove(window.currentOrbitLine);

                    // Safely dispose resources whether it's a Line or a Group
                    if (window.currentOrbitLine.traverse) {
                        window.currentOrbitLine.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    } else {
                        // Fallback for simple meshes/lines
                        if (window.currentOrbitLine.geometry) window.currentOrbitLine.geometry.dispose();
                        if (window.currentOrbitLine.material) window.currentOrbitLine.material.dispose();
                    }

                    window.currentOrbitLine = null;
                    console.log("Removed existing orbit line/group");
                }

                // Draw orbital path if present
                if (trajectoryData.orbit_path && trajectoryData.orbit_path.length > 2) {
                    console.log("Rendering orbit path with", trajectoryData.orbit_path.length, "points");

                    const orbitPoints = [];
                    trajectoryData.orbit_path.forEach((point, index) => {
                        const phi = (90 - point.lat) * (Math.PI / 180);
                        const theta = (point.lon + 180) * (Math.PI / 180);
                        // Use radius from backend
                        const radius = (typeof point.r === 'number') ? point.r : 1.05;
                        const x = -(radius * Math.sin(phi) * Math.cos(theta));
                        const z = radius * Math.sin(phi) * Math.sin(theta);
                        const y = radius * Math.cos(phi);
                        orbitPoints.push(new THREE.Vector3(x, y, z));
                    });
                    // Use LineSegments for dashed effect
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);

                    // Create a group for the orbit to include a glow effect
                    const orbitGroup = new THREE.Group();

                    // 1. Core Orbit Line (Solid Red Tube)
                    // Create curve from points
                    const orbitCurve = new THREE.CatmullRomCurve3(orbitPoints);
                    // Close the curve if it loops? Usually orbit_path is a full loop segment, but let's leave open to match points.
                    orbitCurve.closed = true;

                    const orbitTubeRadius = 0.003;
                    const orbitSegments = orbitPoints.length * 6;

                    const orbitTubeGeo = new THREE.TubeGeometry(orbitCurve, orbitSegments, orbitTubeRadius, 8, true);
                    const orbitMat = new THREE.MeshBasicMaterial({
                        color: 0xFF0000, // Explicit Red
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                    const orbitMesh = new THREE.Mesh(orbitTubeGeo, orbitMat);
                    orbitGroup.add(orbitMesh);

                    // 2. Subtle Glow for Orbit
                    const orbitGlowRadius = orbitTubeRadius * 2.5;
                    const orbitGlowGeo = new THREE.TubeGeometry(orbitCurve, orbitSegments, orbitGlowRadius, 8, true);
                    const orbitGlowMat = new THREE.MeshBasicMaterial({
                        color: 0xFF0000,
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const orbitGlowMesh = new THREE.Mesh(orbitGlowGeo, orbitGlowMat);
                    orbitGroup.add(orbitGlowMesh);

                    if (globe) {
                        globe.add(orbitGroup);
                    } else {
                        scene.add(orbitGroup);
                    }
                    window.currentOrbitLine = orbitGroup;
                    console.log("Orbit group added with glow");
                }

                // Force a render
                renderer.render(scene, camera);
                console.log("Forced render");

                // Auto-center view on the launch site (trajectory start)
                // "Slightly left of center" means we center the camera on a longitude slightly East of the launch site.
                if (trajectoryData.trajectory.length > 0) {
                    const startLon = trajectoryData.trajectory[0].lon;
                    // Calibration: roughly 4.7 rad is Lon 0 (Africa). Increasing rotation moves view West (decreasing Lon center).
                    // Formula: rotY = 4.7 - (TargetLon * PI/180)
                    // We want CenterLon = StartLon + 25 degrees (so point is 25 deg left/West of center)
                    const offsetDeg = 25;
                    const targetLon = startLon + offsetDeg;
                    const targetRot = 4.7 - (targetLon * (Math.PI / 180));

                    // Normalize to 0..2PI just to be clean, though not strictly required
                    globe.rotation.y = targetRot % (2 * Math.PI);
                    console.log(`Auto-rotated to ${globe.rotation.y.toFixed(2)} rad for start lon ${startLon}`);
                }

            } catch (error) {
                console.error("Error in updateTrajectory:", error);
            }
        }
        // Expose function to window as early as possible
        window.updateTrajectory = updateTrajectory;

        // Initialize and start animation, but ensure THREE is available first
        console.log("Starting initialization (waiting for THREE if offline)...");
        if (window.__ensureThreeAndBoot) {
            window.__ensureThreeAndBoot(function () {
                try { init(); } catch (e) { console.error('Init failed, will retry shortly:', e); setTimeout(function () { window.__ensureThreeAndBoot(init); }, 4000); }
            });
        } else {
            // Fallback: try to init directly
            try { init(); } catch (e) { console.error('Init failed before loader available:', e); }
        }

        // Expose functions to Qt

        // If we were offline at start, try to add clouds when we come online
        window.addEventListener('online', function () {
            try {
                if (!globe) return;
                if (globe.getObjectByName && !globe.getObjectByName('clouds')) {
                    const textureLoader = new THREE.TextureLoader();
                    const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
                    textureLoader.load(
                        'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
                        function (cloudTexture) {
                            const cloudMaterial = new THREE.MeshLambertMaterial({
                                map: cloudTexture,
                                transparent: true,
                                opacity: 0.8,
                                alphaMap: cloudTexture
                            });
                            const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                            clouds.name = 'clouds';
                            globe.add(clouds);
                            console.log('Cloud layer added after going online');
                        }
                    );
                }
            } catch (e) {
                console.warn('Failed to add clouds after going online:', e);
            }
        });

        // Make globe interactive
        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            userInteracting = true;
            isInMomentum = false; // Stop momentum when user takes control
            momentumX = 0;
            momentumY = 0;
            lastTime = Date.now();
            previousMousePosition = { x: event.clientX, y: event.clientY };
            touchMode = 'drag';
            cumulativeDragDistance = 0;
            hadPinchSinceLastDrag = false;
            resetRecentMoves();
        });

        document.addEventListener('mousemove', (event) => {
            if (!isMouseDown) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            cumulativeDragDistance += Math.hypot(deltaX, deltaY);

            // Adjust y-rotation direction based on globe orientation to prevent reversal when upside down
            const yDirection = Math.cos(globe.rotation.x) > 0 ? 1 : -1;

            // Track velocity for momentum (bake in current orientation)
            if (deltaTime > 0) {
                momentumX = (deltaX * yDirection) / deltaTime * 0.1; // Scale for smooth momentum
                momentumY = (deltaY) / deltaTime * 0.1;
                lastDeltaX = deltaX; lastDeltaY = deltaY; lastMoveTimeMs = currentTime;
                pushRecentMove(deltaX, deltaY, yDirection, deltaTime, currentTime);
            }

            globe.rotation.y += deltaX * 0.005 * yDirection;
            if (!window.__userRotOffset) window.__userRotOffset = 0;
            window.__userRotOffset += deltaX * 0.005 * yDirection;
            globe.rotation.x += deltaY * 0.005;
            clampRotationX();

            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        function shouldStartMomentum() {
            const now = Date.now();
            const recent = (now - lastMoveTimeMs) < RECENT_MS_THRESHOLD;
            const movedEnough = cumulativeDragDistance > DRAG_DEADZONE_PX;
            const { vx, vy, mag } = getAveragedVelocity();
            return (
                touchMode === 'drag' &&
                !hadPinchSinceLastDrag &&
                recent &&
                movedEnough &&
                mag > MIN_RELEASE_VELOCITY
            );
        }

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
            const start = shouldStartMomentum();
            if (start) {
                const v = getAveragedVelocity();
                momentumX = v.vx; momentumY = v.vy;
            }
            isInMomentum = start;
            if (!isInMomentum) { momentumX = 0; momentumY = 0; }
            touchMode = 'none';
            resetRecentMoves();
            // Mouse up ends direct interaction; momentum may continue but that's not a touch
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });

        // Touch support for mobile
        document.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                isMouseDown = true;
                userInteracting = true;
                isInMomentum = false; // Stop momentum when user takes control
                momentumX = 0;
                momentumY = 0;
                lastTime = Date.now();
                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                touchMode = 'drag';
                cumulativeDragDistance = 0;
                // Do not reset hadPinchSinceLastDrag here (pinch may have preceded)
                resetRecentMoves();
            } else if (event.touches.length >= 2) {
                // Transition into pinch mode
                touchMode = 'pinch';
                isMouseDown = false;
                isInMomentum = false;
                momentumX = 0; momentumY = 0;
                hadPinchSinceLastDrag = true; // ensure no inertia on release after any pinch
                resetRecentMoves();
                userInteracting = true;
            }
        });

        document.addEventListener('touchmove', (event) => {
            if (!isMouseDown || event.touches.length !== 1) return;

            event.preventDefault();

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;
            cumulativeDragDistance += Math.hypot(deltaX, deltaY);

            // Adjust y-rotation direction based on globe orientation to prevent reversal when upside down
            const yDirection = Math.cos(globe.rotation.x) > 0 ? 1 : -1;

            // Track velocity for momentum (bake in current orientation)
            if (deltaTime > 0) {
                momentumX = (deltaX * yDirection) / deltaTime * 0.1;
                momentumY = (deltaY) / deltaTime * 0.1;
                lastDeltaX = deltaX; lastDeltaY = deltaY; lastMoveTimeMs = currentTime;
                pushRecentMove(deltaX, deltaY, yDirection, deltaTime, currentTime);
            }

            globe.rotation.y += deltaX * 0.005 * yDirection;
            if (!window.__userRotOffset) window.__userRotOffset = 0;
            window.__userRotOffset += deltaX * 0.005 * yDirection;
            globe.rotation.x += deltaY * 0.005;
            clampRotationX();

            previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }, { passive: false });

        function endTouchCommon() {
            // Only start momentum if we were dragging, not pinching, and had a recent move
            isMouseDown = false;
            const start = shouldStartMomentum();
            if (start) {
                const v = getAveragedVelocity();
                momentumX = v.vx; momentumY = v.vy;
            }
            isInMomentum = start;
            if (!isInMomentum) { momentumX = 0; momentumY = 0; }
            // Reset mode when all touches are gone
            touchMode = 'none';
            hadPinchSinceLastDrag = false; // reset after gesture fully ends
            resetRecentMoves();
        }

        document.addEventListener('touchend', (e) => {
            // If there are still touches, don't finalize drag end here (multi-touch transition)
            if (e.touches && e.touches.length > 0) return;
            endTouchCommon();
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });

        document.addEventListener('touchcancel', () => {
            endTouchCommon();
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });


        // Provide guarded hooks for external callers (Qt) to control spin/animation.
        // These respect active user interaction and will resume deterministically.
        window.clearInteraction = function () {
            try { if (window.globeAutospinGuard) console.log('[globe] clearInteraction()'); } catch (e) { }
            activePointers = 0;
            userInteracting = false;
            isInMomentum = false;
            momentumX = 0; momentumY = 0;
            touchMode = 'none';
            resetRecentMoves();
        };
        window.resumeSpin = function () {
            if (userInteracting) { pendingSystemResume = true; return; }
            systemPaused = false;
            autoSpinEnabled = true;
            if (controls && typeof controls.autoRotate === 'boolean') controls.autoRotate = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            try { if (window.globeAutospinGuard) console.log('[globe] resumeSpin invoked'); } catch (e) { }
        };
        window.forceResumeSpin = function () {
            window.clearInteraction();
            systemPaused = false;
            autoSpinEnabled = true;
            if (controls && typeof controls.autoRotate === 'boolean') controls.autoRotate = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            pendingSystemResume = false;
            try { if (window.globeAutospinGuard) console.log('[globe] forceResumeSpin invoked'); } catch (e) { }
        };
        window.pauseSpin = function () {
            systemPaused = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            try { if (window.globeAutospinGuard) console.log('[globe] pauseSpin invoked'); } catch (e) { }
        };
        window.startSpin = function () { if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };
        window.resumeAnimation = function () { if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };
        window.startAnimation = function () { if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };

        // Handle window focus/visibility to avoid "stuck interaction" states and auto-resume when appropriate
        window.addEventListener('blur', function () {
            if (window.globeAutospinGuard) {
                window.clearInteraction();
            }
        });
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                if (window.globeAutospinGuard) {
                    window.clearInteraction();
                    // If we were pending a resume, complete it now
                    if (pendingSystemResume) { pendingSystemResume = false; systemPaused = false; autoSpinEnabled = true; }
                }
            }
        });

        // Inactivity fallback: if marked interacting but no activity and no pointers, clear it
        setInterval(function () {
            try {
                if (!window.globeAutospinGuard) return;
                const now = Date.now();
                if (userInteracting && activePointers === 0 && (now - lastMoveTimeMs) > 1500) {
                    console.log('[globe] clearing stale interaction due to inactivity');
                    window.clearInteraction();
                }
            } catch (e) { }
        }, 1000);

        // Visibility instrumentation
        document.addEventListener('visibilitychange', function () {
            try { console.log('[globe] visibilitychange:', document.visibilityState); } catch (e) { }
            if (document.visibilityState === 'visible') {
                // When page becomes visible, allow a small grace then resume if allowed
                setTimeout(function () {
                    if (!userPaused && window.globeAutospinGuard !== false) {
                        window.resumeSpin();
                    }
                }, 250);
            }
        });

        // Self-healing watchdog: if frames stop for >3s while visible, resume
        (function () {
            const CHECK_MS = 1000;
            const STALL_MS = 3000;
            setInterval(function () {
                if (typeof document === 'undefined') return;
                if (document.visibilityState !== 'visible') return;
                if (window.globeAutospinGuard === false) return;
                const now = performance.now();
                if (now - __lastRenderTs > STALL_MS) {
                    try { console.log('[globe] watchdog: render stalled, attempting resume'); } catch (e) { }
                    window.resumeSpin();
                }
            }, CHECK_MS);
        })();

        // Play/Pause button functionality
        // Play/Pause button functionality
        document.getElementById('playPauseBtn').addEventListener('click', () => {
            userPaused = !userPaused;
            isAutoRotatePaused = (userPaused || systemPaused);

            // "Actually works": If paused, kill any active momentum immediately
            if (userPaused) {
                isInMomentum = false;
                momentumX = 0;
                momentumY = 0;
            }

            const button = document.getElementById('playPauseBtn');
            const icon = button.querySelector('i');
            if (isAutoRotatePaused) {
                icon.className = 'fas fa-play';
            } else {
                icon.className = 'fas fa-pause';
            }
        });

        // Initial instrumentation
        try { console.log('[globe] script loaded; awaiting boot'); } catch (e) { }

        // Theme handling
        window.setTheme = function (theme) {
            try { console.log('[globe] setTheme:', theme); } catch (e) { }
            if (theme === 'light') {
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
            }
        };
    </script>
</body>

</html>