<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth Globe</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #playPauseBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #playPauseBtn:hover {
            background: rgba(0, 0, 0, 0.9);
        }
    </style>
    <script>
        // Lightweight loader that ensures THREE is available even if we started offline.
        // We avoid hard-failing when there's no network at boot and retry when it comes back.
        (function(){
            function injectThree(onReady){
                if (window.THREE) { onReady && onReady(); return; }
                try {
                    var s = document.createElement('script');
                    s.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                    s.async = true;
                    s.onload = function(){ onReady && onReady(); };
                    s.onerror = function(){
                        // Retry shortly; also wait for online event
                        setTimeout(function(){ injectThree(onReady); }, 4000);
                    };
                    document.head.appendChild(s);
                } catch(e){
                    setTimeout(function(){ injectThree(onReady); }, 4000);
                }
            }
            // Expose a boot function used at the bottom of the file
            window.__ensureThreeAndBoot = function(cb){
                if (window.THREE) { cb && cb(); return; }
                injectThree(cb);
                // Also try again when network comes online
                window.addEventListener('online', function(){ injectThree(cb); }, { once: true });
            };
        })();
    </script>
</head>
<body>
    <button id="playPauseBtn"><i class="fas fa-pause"></i></button>
    <script>
        let scene, camera, renderer, globe, controls, trajectoryLine, launchMarker;
        let momentumX = 0, momentumY = 0;
        let isInMomentum = false;
        let lastTime = Date.now();
        let isAutoRotatePaused = false; // kept for backward compatibility with existing code
        // Distinguish between user-initiated pause and system-initiated pause (e.g., during app/network events)
        let userPaused = false;
        let systemPaused = false;
        let pendingSystemResume = false; // set when resume is requested during active interaction
        // Explicit auto spin enable independent of OrbitControls (more robust on Qt WebEngine)
        let autoSpinEnabled = true;
        // Track if the user is actively interacting (mouse down or any touch contact)
        // This is used to prevent auto-rotation from starting/resuming while touching.
        let userInteracting = false;
        // Track active pointer contacts (helps on Linux/Qt where pointer events may be used)
        let activePointers = 0;
        // Track gesture mode to avoid mixing pinch and drag states
        // Values: 'none' | 'drag' | 'pinch'
        let touchMode = 'none';
        // Track last deltas to decide whether to start momentum on release
        let lastDeltaX = 0, lastDeltaY = 0;
        let lastMoveTimeMs = 0;
        // Drag deadzone and pinch tracking
        const DRAG_DEADZONE_PX = 8;           // ignore tiny movements
        const RECENT_MS_THRESHOLD = 110;      // last movement must be recent
        const MIN_RELEASE_VELOCITY = 0.002;   // minimum velocity to start inertia
        let cumulativeDragDistance = 0;       // reset per-drag
        let hadPinchSinceLastDrag = false;    // cancels inertia if pinch occurred

        // Short-window velocity averaging to avoid "opposite recoil"
        const VELOCITY_WINDOW_MS = 140;       // average last ~140 ms of motion
        let recentMoves = [];                 // entries: { t, dt, dxAdj, dy }

        function resetRecentMoves(){ recentMoves = []; }
        function pushRecentMove(dx, dy, yDirection, dt, now){
            if (!isFinite(dt) || dt <= 0) return;
            const entry = {
                t: now,
                dt: dt,
                dxAdj: dx * yDirection,
                dy: dy
            };
            recentMoves.push(entry);
            // Trim old entries beyond window
            const cutoff = now - VELOCITY_WINDOW_MS;
            while (recentMoves.length && recentMoves[0].t < cutoff) {
                recentMoves.shift();
            }
            // Keep list reasonably small (safety cap)
            if (recentMoves.length > 20) recentMoves.splice(0, recentMoves.length - 20);
        }
        function getAveragedVelocity(){
            if (!recentMoves.length) return { vx: 0, vy: 0, mag: 0 };
            let sumDx = 0, sumDy = 0, sumDt = 0;
            for (const m of recentMoves){
                sumDx += m.dxAdj;
                sumDy += m.dy;
                sumDt += m.dt;
            }
            if (sumDt <= 0) return { vx: 0, vy: 0, mag: 0 };
            // Scale to match previous tuning (0.1 factor used before)
            const vx = (sumDx / sumDt) * 0.1;
            const vy = (sumDy / sumDt) * 0.1;
            const mag = Math.abs(vx) + Math.abs(vy);
            return { vx, vy, mag };
        }

        // Zoom parameters
        const DEFAULT_CAMERA_Z = 1.8;      // Existing default distance (keep as farthest zoom-out)
        const CAMERA_MIN_Z = 1.1;          // How close you can zoom in (tweak if needed)
        const CAMERA_MAX_Z = DEFAULT_CAMERA_Z; // Clamp max to current default
        const ZOOM_STEP = 0.1;             // Base step for wheel zoom adjustments
        let pinchStartDistance = null;
        let pinchStartZ = null;

        function init() {
            try {
                // Scene
                scene = new THREE.Scene();

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = DEFAULT_CAMERA_Z; // Closer to make globe larger

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0); // Transparent background
                document.body.appendChild(renderer.domElement);
                // Allow us to prevent default touch gestures for custom pinch zoom
                renderer.domElement.style.touchAction = 'none';

                // Globe geometry
                const geometry = new THREE.SphereGeometry(1, 64, 64);

                // Earth texture - try multiple paths
                const textureLoader = new THREE.TextureLoader();

                textureLoader.load(
                    '../assets/images/earth_texture.jpg',
                    function(texture) {
                        // Material
                        const material = new THREE.MeshPhongMaterial({
                            map: texture,
                            transparent: true,
                            opacity: 0.9
                        });

                        // Mesh
                        globe = new THREE.Mesh(geometry, material);
                        scene.add(globe);

                        // Set initial tilt for better orbit visibility
                        globe.rotation.x = 0.3;

                        // Cloud layer
                        const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
                        textureLoader.load(
                            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
                            function(cloudTexture) {
                                const cloudMaterial = new THREE.MeshLambertMaterial({
                                    map: cloudTexture,
                                    transparent: true,
                                    opacity: 0.8,
                                    alphaMap: cloudTexture
                                });
                                const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                                clouds.name = 'clouds';
                                globe.add(clouds);
                                console.log("Cloud layer added");
                            },
                            undefined,
                            function(error) {
                                console.error("Error loading cloud texture:", error);
                            }
                        );

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(1, 1, 1);
                        scene.add(directionalLight);

                        // Start animation
                        animate();
                    },
                    function(progress) {
                        // Loading progress
                    },
                    function(error) {
                        console.error("Error loading texture:", error);
                        // Fallback: create globe without texture
                        const material = new THREE.MeshPhongMaterial({
                            color: 0x2233ff,
                            transparent: true,
                            opacity: 0.9
                        });

                        globe = new THREE.Mesh(geometry, material);
                        scene.add(globe);

                        // Set initial tilt for better orbit visibility
                        globe.rotation.x = 0.3;

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(1, 1, 1);
                        scene.add(directionalLight);

                        animate();
                    }
                );

                // Controls
                controls = {
                    autoRotate: true,
                    autoRotateSpeed: -0.3,
                    enableZoom: true,
                    enablePan: false,
                    enableRotate: true
                };

                // Handle WebGL context loss/restoration (can happen during network/GPU changes)
                try {
                    const canvas = renderer && renderer.domElement;
                    if (canvas) {
                        canvas.addEventListener('webglcontextlost', function(e){
                            try { console.log('[globe] WebGL context lost'); } catch(_e){}
                            // Prevent default so browser will try to restore context
                            if (e && e.preventDefault) e.preventDefault();
                            systemPaused = true;
                            isAutoRotatePaused = (userPaused || systemPaused);
                        }, false);
                        canvas.addEventListener('webglcontextrestored', function(){
                            try { console.log('[globe] WebGL context restored'); } catch(_e){}
                            systemPaused = false;
                            isAutoRotatePaused = (userPaused || systemPaused);
                            // Re-arm the animation loop in case rAF chain was broken
                            try { requestAnimationFrame(animate); } catch(_e){}
                            // Ensure spin resumes promptly
                            setTimeout(function(){ try { if (window.forceResumeSpin) forceResumeSpin(); else if (window.resumeSpin) resumeSpin(); } catch(_e){} }, 0);
                        }, false);
                    }
                } catch(_e) { /* ignore */ }

                // Handle window resize
                window.addEventListener('resize', onWindowResize, false);
                // Mouse wheel zoom (clamped so you can't zoom out past default)
                renderer.domElement.addEventListener('wheel', onWheelZoom, { passive: false });
                // Touch pinch zoom support
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                console.log("Event listeners added");

                // Disable in-page context menu (right-click/long-press)
                try { document.addEventListener('contextmenu', function(e){ e.preventDefault(); }, { passive: false }); } catch(_e) {}

            } catch (error) {
                console.error("Error during initialization:", error);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function clampCameraZ(z) {
            return Math.max(CAMERA_MIN_Z, Math.min(CAMERA_MAX_Z, z));
        }

        function onWheelZoom(event) {
            // Prevent page/system scrolling
            event.preventDefault();
            if (!camera) return;
            // Normalize wheel delta: negative => zoom in; positive => zoom out
            const delta = Math.sign(event.deltaY);
            let newZ = camera.position.z + (delta * ZOOM_STEP);
            newZ = clampCameraZ(newZ);
            camera.position.z = newZ;
        }

        function clampRotationX() {
            // Avoid flipping the globe which can invert drag directions
            const maxTilt = Math.PI / 2 - 0.05; // small margin from 90°
            if (!globe) return;
            if (globe.rotation.x > maxTilt) globe.rotation.x = maxTilt;
            if (globe.rotation.x < -maxTilt) globe.rotation.x = -maxTilt;
        }

        function distanceBetweenTouches(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.hypot(dx, dy);
        }

        function onTouchStart(event) {
            if (event.touches && event.touches.length === 2) {
                event.preventDefault();
                pinchStartDistance = distanceBetweenTouches(event.touches[0], event.touches[1]);
                pinchStartZ = camera ? camera.position.z : null;
                // Enter pinch mode and cancel any drag momentum state
                touchMode = 'pinch';
                isInMomentum = false;
                momentumX = 0; momentumY = 0;
                // Ensure drag state is not considered active
                isMouseDown = false;
                userInteracting = true;
            }
        }

        function onTouchMove(event) {
            if (event.touches && event.touches.length === 2 && pinchStartDistance && pinchStartZ != null) {
                event.preventDefault();
                const currentDistance = distanceBetweenTouches(event.touches[0], event.touches[1]);
                if (currentDistance > 0) {
                    // Ratio > 1 means fingers moved apart (zoom in)
                    const ratio = pinchStartDistance / currentDistance;
                    // Map ratio to z change around the start z
                    let targetZ = pinchStartZ * ratio;
                    // Ease the effect to avoid too aggressive zooming
                    targetZ = pinchStartZ + (targetZ - pinchStartZ) * 0.5;
                    camera.position.z = clampCameraZ(targetZ);
                }
            }
        }

        function onTouchEnd(event) {
            if (!event.touches || event.touches.length < 2) {
                pinchStartDistance = null;
                pinchStartZ = null;
                // Leave pinch mode; do not start momentum here (handled in document touchend for drag)
                if (touchMode === 'pinch' && (!event.touches || event.touches.length === 0)) {
                    touchMode = 'none';
                }
                if (!event.touches || event.touches.length === 0) {
                    userInteracting = false;
                }
            }
        }

        let __lastRenderTs = performance.now();
        let __lastResumeLogTs = 0;
        function animate() {
            requestAnimationFrame(animate);

            if (globe) {
                if (isInMomentum) {
                    // Apply momentum directly in the same frame of reference it was recorded
                    // (we bake orientation into momentum at capture time to avoid post-release flips)
                    globe.rotation.y += momentumX;
                    globe.rotation.x += momentumY;
                    clampRotationX();

                    // Decay momentum
                    // Slightly stronger damping to reduce perceived recoil
                    momentumX *= 0.93; // Friction/damping
                    momentumY *= 0.93;

                    // Check if momentum is low enough to return to auto-rotation
                    if (Math.abs(momentumX) < 0.0001 && Math.abs(momentumY) < 0.0001) {
                        isInMomentum = false;
                        momentumX = 0;
                        momentumY = 0;
                    }
                } else if (autoSpinEnabled && !userPaused && !systemPaused && !userInteracting) {
                    // Normal auto-rotation (decoupled from OrbitControls)
                    const baseSpeed = (controls && typeof controls.autoRotateSpeed === 'number') ? controls.autoRotateSpeed : 2.0;
                    globe.rotation.y += baseSpeed * 0.01;
                }
            }

            // Rotate clouds slower than the globe
            const clouds = scene.getObjectByName('clouds');
            if (clouds) {
                clouds.rotation.y += 0.0005;
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }

            // Track last render timestamp for watchdog
            __lastRenderTs = performance.now();
        }

        function updateTrajectory(trajectoryData) {            // Remove existing trajectory line
            if (trajectoryLine) {
                if (globe) globe.remove(trajectoryLine);
                scene.remove(trajectoryLine);
                trajectoryLine.geometry.dispose();
                trajectoryLine.material.dispose();
                console.log("Removed existing trajectory");
            }

            // Remove existing launch marker
            if (launchMarker) {
                if (globe) globe.remove(launchMarker);
                scene.remove(launchMarker);
                launchMarker.geometry.dispose();
                launchMarker.material.dispose();
                console.log("Removed existing launch marker");
            }

            if (!trajectoryData || !trajectoryData.trajectory || trajectoryData.trajectory.length < 2) {
                console.log("No valid trajectory data");
                return;
            }

            console.log("Creating trajectory with", trajectoryData.trajectory.length, "points");
            console.log("Orbit path present:", !!trajectoryData.orbit_path, "with", trajectoryData.orbit_path ? trajectoryData.orbit_path.length : 0, "points");

            try {
                // Determine a physically sensible visual radius for the orbit based on orbit type.
                // We cannot draw true scale (e.g., GEO ~ 6.6x Earth radius), so we compress with a cap.
                const EARTH_RADIUS_KM = 6371.0;
                function chooseOrbitAltKm(orbitLabel) {
                    const o = (orbitLabel || '').toString().toLowerCase();
                    if (o.includes('suborbital')) return 100;            // ~Kármán line
                    if (o.includes('sso') || o.includes('sun-synchronous')) return 550; // common SSO band
                    if (o.includes('polar')) return 600;                 // typical polar LEO
                    if (o.includes('leo')) return 400;                   // ISS-like LEO
                    if (o.includes('gto') || o.includes('geostationary transfer')) return 20000; // representative altitude
                    if (o.includes('geo') || o.includes('geostationary')) return 35786; // GEO altitude
                    if (o.includes('meo') || o.includes('gps')) return 20200; // MEO/GNSS
                    if (o.includes('heeo') || o.includes('molniya')) return 40000; // highly elliptical apogee representative
                    return 800; // default LEO-ish
                }
                function computeOrbitRadius(orbitLabel) {
                    const altKm = chooseOrbitAltKm(orbitLabel);
                    // Visual compression: add relative altitude, capped to +8%
                    let r = 1.0 + Math.min(altKm / EARTH_RADIUS_KM, 0.08);
                    // Keep above clouds layer (1.01) with a small margin
                    if (r < 1.012) r = 1.012;
                    // Hard safety clamp to avoid drawing too far from globe
                    if (r > 1.08) r = 1.08;
                    return r;
                }

                const orbitLabel = trajectoryData && trajectoryData.orbit ? trajectoryData.orbit : '';
                const ORBIT_RADIUS = computeOrbitRadius(orbitLabel);
                const TAIL_ZFIGHT_EPS = 0.0006; // keep trajectory just below orbit line to avoid z-fighting
                console.log(`Orbit label: '${orbitLabel}' -> visual radius ${ORBIT_RADIUS.toFixed(4)}`);
                // Create trajectory points from the curved lat/lon data
                const points = [];

                // Constants to keep visual logic centralized
                const TRAJ_START_RADIUS = 1.01; // Trajectory slightly above surface at liftoff
                const TRAJ_BULGE_MAX = 0.02;    // Max additional bulge at mid-arc (will be clamped)

                trajectoryData.trajectory.forEach((point, index) => {
                    // Convert lat/lon to 3D coordinates on sphere with subtle arc height
                    const phi = (90 - point.lat) * (Math.PI / 180);
                    const theta = (point.lon + 180) * (Math.PI / 180);

                    // Ensure the tail of the trajectory meets the orbit radius visually.
                    // We interpolate the base trajectory radius from liftoff to orbit radius,
                    // and add a small mid-arc bulge that goes to zero at both ends.
                    const progress = index / (trajectoryData.trajectory.length - 1);
                    const baseInterp = TRAJ_START_RADIUS + (ORBIT_RADIUS - TRAJ_START_RADIUS) * progress;
                    const bulge = TRAJ_BULGE_MAX * Math.sin(progress * Math.PI); // 0 at ends, max at middle
                    let radius = baseInterp + bulge;
                    // Do not exceed the orbit radius to avoid separation; keep a tiny epsilon below to prevent z-fighting
                    if (radius > ORBIT_RADIUS - TAIL_ZFIGHT_EPS) radius = ORBIT_RADIUS - TAIL_ZFIGHT_EPS;

                    const x = -(radius * Math.sin(phi) * Math.cos(theta));
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    const y = radius * Math.cos(phi);

                    points.push(new THREE.Vector3(x, y, z));
                });

                console.log("Created", points.length, "3D points");

                // Create trajectory geometry and material
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0xff4444,
                    linewidth: 3,
                    transparent: true,
                    opacity: 0.8
                });

                // Create trajectory line
                trajectoryLine = new THREE.Line(geometry, material);

                // Add trajectory as a child of the globe so it rotates with it
                if (globe) {
                    globe.add(trajectoryLine);
                    console.log("Trajectory line added as child of globe");
                } else {
                    scene.add(trajectoryLine);
                    console.log("Trajectory line added to scene (globe not available)");
                }

                // Removed launch site red dot marker per request; keep only the trajectory line

                // Remove previous orbit line if it exists
                if (window.currentOrbitLine) {
                    if (globe) globe.remove(window.currentOrbitLine);
                    scene.remove(window.currentOrbitLine);
                    window.currentOrbitLine.geometry.dispose();
                    window.currentOrbitLine.material.dispose();
                    window.currentOrbitLine = null;
                    console.log("Removed existing orbit line");
                }

                // Draw orbital path if present
                if (trajectoryData.orbit_path && trajectoryData.orbit_path.length > 2) {
                    console.log("Rendering orbit path with", trajectoryData.orbit_path.length, "points");

                    const orbitPoints = [];
                    trajectoryData.orbit_path.forEach((point, index) => {
                        const phi = (90 - point.lat) * (Math.PI / 180);
                        const theta = (point.lon + 180) * (Math.PI / 180);
                        // Keep orbit at the computed visual radius for this orbit type
                        const radius = ORBIT_RADIUS;
                        const x = -(radius * Math.sin(phi) * Math.cos(theta));
                        const z = radius * Math.sin(phi) * Math.sin(theta);
                        const y = radius * Math.cos(phi);
                        orbitPoints.push(new THREE.Vector3(x, y, z));
                    });
                    // Use LineSegments for dashed effect
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                    const orbitMaterial = new THREE.LineDashedMaterial({
                        color: 0x00ffff,
                        linewidth: 2,
                        dashSize: 0.03,
                        gapSize: 0.02,
                        transparent: true,
                        opacity: 0.7
                    });
                    const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                    orbitLine.computeLineDistances();
                    if (globe) {
                        globe.add(orbitLine);
                    } else {
                        scene.add(orbitLine);
                    }
                    window.currentOrbitLine = orbitLine;
                    console.log("Orbit line added");
                }

                // Force a render
                renderer.render(scene, camera);
                console.log("Forced render");

            } catch (error) {
                console.error("Error in updateTrajectory:", error);
            }
        }

        // Initialize and start animation, but ensure THREE is available first
        console.log("Starting initialization (waiting for THREE if offline)...");
        if (window.__ensureThreeAndBoot) {
            window.__ensureThreeAndBoot(function(){
                try { init(); } catch(e) { console.error('Init failed, will retry shortly:', e); setTimeout(function(){ window.__ensureThreeAndBoot(init); }, 4000); }
            });
        } else {
            // Fallback: try to init directly
            try { init(); } catch(e) { console.error('Init failed before loader available:', e); }
        }

        // Expose functions to Qt
        window.updateTrajectory = updateTrajectory;

        // If we were offline at start, try to add clouds when we come online
        window.addEventListener('online', function(){
            try {
                if (!globe) return;
                if (globe.getObjectByName && !globe.getObjectByName('clouds')) {
                    const textureLoader = new THREE.TextureLoader();
                    const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
                    textureLoader.load(
                        'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
                        function(cloudTexture) {
                            const cloudMaterial = new THREE.MeshLambertMaterial({
                                map: cloudTexture,
                                transparent: true,
                                opacity: 0.8,
                                alphaMap: cloudTexture
                            });
                            const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                            clouds.name = 'clouds';
                            globe.add(clouds);
                            console.log('Cloud layer added after going online');
                        }
                    );
                }
            } catch(e) {
                console.warn('Failed to add clouds after going online:', e);
            }
        });

        // Make globe interactive
        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            userInteracting = true;
            isInMomentum = false; // Stop momentum when user takes control
            momentumX = 0;
            momentumY = 0;
            lastTime = Date.now();
            previousMousePosition = { x: event.clientX, y: event.clientY };
            touchMode = 'drag';
            cumulativeDragDistance = 0;
            hadPinchSinceLastDrag = false;
            resetRecentMoves();
        });

        document.addEventListener('mousemove', (event) => {
            if (!isMouseDown) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            cumulativeDragDistance += Math.hypot(deltaX, deltaY);

            // Adjust y-rotation direction based on globe orientation to prevent reversal when upside down
            const yDirection = Math.cos(globe.rotation.x) > 0 ? 1 : -1;

            // Track velocity for momentum (bake in current orientation)
            if (deltaTime > 0) {
                momentumX = (deltaX * yDirection) / deltaTime * 0.1; // Scale for smooth momentum
                momentumY = (deltaY) / deltaTime * 0.1;
                lastDeltaX = deltaX; lastDeltaY = deltaY; lastMoveTimeMs = currentTime;
                pushRecentMove(deltaX, deltaY, yDirection, deltaTime, currentTime);
            }

            globe.rotation.y += deltaX * 0.005 * yDirection;
            globe.rotation.x += deltaY * 0.005;
            clampRotationX();

            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        function shouldStartMomentum() {
            const now = Date.now();
            const recent = (now - lastMoveTimeMs) < RECENT_MS_THRESHOLD;
            const movedEnough = cumulativeDragDistance > DRAG_DEADZONE_PX;
            const { vx, vy, mag } = getAveragedVelocity();
            return (
                touchMode === 'drag' &&
                !hadPinchSinceLastDrag &&
                recent &&
                movedEnough &&
                mag > MIN_RELEASE_VELOCITY
            );
        }

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
            const start = shouldStartMomentum();
            if (start) {
                const v = getAveragedVelocity();
                momentumX = v.vx; momentumY = v.vy;
            }
            isInMomentum = start;
            if (!isInMomentum) { momentumX = 0; momentumY = 0; }
            touchMode = 'none';
            resetRecentMoves();
            // Mouse up ends direct interaction; momentum may continue but that's not a touch
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });

        // Touch support for mobile
        document.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                isMouseDown = true;
                userInteracting = true;
                isInMomentum = false; // Stop momentum when user takes control
                momentumX = 0;
                momentumY = 0;
                lastTime = Date.now();
                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                touchMode = 'drag';
                cumulativeDragDistance = 0;
                // Do not reset hadPinchSinceLastDrag here (pinch may have preceded)
                resetRecentMoves();
            } else if (event.touches.length >= 2) {
                // Transition into pinch mode
                touchMode = 'pinch';
                isMouseDown = false;
                isInMomentum = false;
                momentumX = 0; momentumY = 0;
                hadPinchSinceLastDrag = true; // ensure no inertia on release after any pinch
                resetRecentMoves();
                userInteracting = true;
            }
        });

        document.addEventListener('touchmove', (event) => {
            if (!isMouseDown || event.touches.length !== 1) return;

            event.preventDefault();

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;
            cumulativeDragDistance += Math.hypot(deltaX, deltaY);

            // Adjust y-rotation direction based on globe orientation to prevent reversal when upside down
            const yDirection = Math.cos(globe.rotation.x) > 0 ? 1 : -1;

            // Track velocity for momentum (bake in current orientation)
            if (deltaTime > 0) {
                momentumX = (deltaX * yDirection) / deltaTime * 0.1;
                momentumY = (deltaY) / deltaTime * 0.1;
                lastDeltaX = deltaX; lastDeltaY = deltaY; lastMoveTimeMs = currentTime;
                pushRecentMove(deltaX, deltaY, yDirection, deltaTime, currentTime);
            }

            globe.rotation.y += deltaX * 0.005 * yDirection;
            globe.rotation.x += deltaY * 0.005;
            clampRotationX();

            previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }, { passive: false });

        function endTouchCommon() {
            // Only start momentum if we were dragging, not pinching, and had a recent move
            isMouseDown = false;
            const start = shouldStartMomentum();
            if (start) {
                const v = getAveragedVelocity();
                momentumX = v.vx; momentumY = v.vy;
            }
            isInMomentum = start;
            if (!isInMomentum) { momentumX = 0; momentumY = 0; }
            // Reset mode when all touches are gone
            touchMode = 'none';
            hadPinchSinceLastDrag = false; // reset after gesture fully ends
            resetRecentMoves();
        }

        document.addEventListener('touchend', (e) => {
            // If there are still touches, don't finalize drag end here (multi-touch transition)
            if (e.touches && e.touches.length > 0) return;
            endTouchCommon();
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });

        document.addEventListener('touchcancel', () => {
            endTouchCommon();
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });

        // Pointer event fallbacks (Linux/Qt WebEngine often routes touch via pointer events)
        // We only count non-mouse pointers here to avoid double-handling regular mouse drags.
        renderer.domElement.addEventListener('pointerdown', (e) => {
            if (e && e.pointerType && e.pointerType !== 'mouse') {
                activePointers++;
                userInteracting = true;
            }
        });
        document.addEventListener('pointerup', (e) => {
            if (e && e.pointerType && e.pointerType !== 'mouse') {
                activePointers = Math.max(0, activePointers - 1);
                if (activePointers === 0 && !isMouseDown) {
                    userInteracting = false;
                }
            }
        });
        document.addEventListener('pointercancel', (e) => {
            if (e && e.pointerType && e.pointerType !== 'mouse') {
                activePointers = Math.max(0, activePointers - 1);
                if (activePointers === 0 && !isMouseDown) {
                    userInteracting = false;
                }
            }
        });

        // Provide guarded hooks for external callers (Qt) to control spin/animation.
        // These respect active user interaction and will resume deterministically.
        window.clearInteraction = function(){
            try { if (window.globeAutospinGuard) console.log('[globe] clearInteraction()'); } catch(e){}
            activePointers = 0;
            userInteracting = false;
            isInMomentum = false;
            momentumX = 0; momentumY = 0;
            touchMode = 'none';
            resetRecentMoves();
        };
        window.resumeSpin = function(){
            if (userInteracting) { pendingSystemResume = true; return; }
            systemPaused = false;
            autoSpinEnabled = true;
            if (controls && typeof controls.autoRotate === 'boolean') controls.autoRotate = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            try { if (window.globeAutospinGuard) console.log('[globe] resumeSpin invoked'); } catch(e){}
        };
        window.forceResumeSpin = function(){
            window.clearInteraction();
            systemPaused = false;
            autoSpinEnabled = true;
            if (controls && typeof controls.autoRotate === 'boolean') controls.autoRotate = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            pendingSystemResume = false;
            try { if (window.globeAutospinGuard) console.log('[globe] forceResumeSpin invoked'); } catch(e){}
        };
        window.pauseSpin = function(){
            systemPaused = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            try { if (window.globeAutospinGuard) console.log('[globe] pauseSpin invoked'); } catch(e){}
        };
        window.startSpin = function(){ if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };
        window.resumeAnimation = function(){ if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };
        window.startAnimation = function(){ if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };

        // Handle window focus/visibility to avoid "stuck interaction" states and auto-resume when appropriate
        window.addEventListener('blur', function(){
            if (window.globeAutospinGuard) {
                window.clearInteraction();
            }
        });
        document.addEventListener('visibilitychange', function(){
            if (document.visibilityState === 'visible') {
                if (window.globeAutospinGuard) {
                    window.clearInteraction();
                    // If we were pending a resume, complete it now
                    if (pendingSystemResume) { pendingSystemResume = false; systemPaused = false; autoSpinEnabled = true; }
                }
            }
        });

        // Inactivity fallback: if marked interacting but no activity and no pointers, clear it
        setInterval(function(){
            try {
                if (!window.globeAutospinGuard) return;
                const now = Date.now();
                if (userInteracting && activePointers === 0 && (now - lastMoveTimeMs) > 1500) {
                    console.log('[globe] clearing stale interaction due to inactivity');
                    window.clearInteraction();
                }
            } catch(e){}
        }, 1000);

        // Visibility instrumentation
        document.addEventListener('visibilitychange', function(){
            try { console.log('[globe] visibilitychange:', document.visibilityState); } catch(e){}
            if (document.visibilityState === 'visible') {
                // When page becomes visible, allow a small grace then resume if allowed
                setTimeout(function(){
                    if (!userPaused && window.globeAutospinGuard !== false) {
                        window.resumeSpin();
                    }
                }, 250);
            }
        });

        // Self-healing watchdog: if frames stop for >3s while visible, resume
        (function(){
            const CHECK_MS = 1000;
            const STALL_MS = 3000;
            setInterval(function(){
                if (typeof document === 'undefined') return;
                if (document.visibilityState !== 'visible') return;
                if (window.globeAutospinGuard === false) return;
                const now = performance.now();
                if (now - __lastRenderTs > STALL_MS) {
                    try { console.log('[globe] watchdog: render stalled, attempting resume'); } catch(e){}
                    // Nudge auto-rotation state
                    window.resumeSpin && window.resumeSpin();
                    // Re-arm the animation loop in case rAF chain stopped
                    try { requestAnimationFrame(animate); } catch(_e){}
                }
            }, CHECK_MS);
        })();

        // Play/Pause button functionality
        document.getElementById('playPauseBtn').addEventListener('click', () => {
            userPaused = !userPaused;
            isAutoRotatePaused = (userPaused || systemPaused);
            const button = document.getElementById('playPauseBtn');
            const icon = button.querySelector('i');
            if (isAutoRotatePaused) {
                icon.className = 'fas fa-play';
            } else {
                icon.className = 'fas fa-pause';
            }
        });

        // Initial instrumentation
        try { console.log('[globe] script loaded; awaiting boot'); } catch(e){}
    </script>
</body>
</html>