<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth Globe</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #playPauseBtn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #playPauseBtn:hover {
            background: rgba(0, 0, 0, 0.9);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <button id="playPauseBtn"><i class="fas fa-pause"></i></button>
    <script>
        let scene, camera, renderer, globe, controls, trajectoryLine, launchMarker;
        let momentumX = 0, momentumY = 0;
        let isInMomentum = false;
        let lastTime = Date.now();
        let isAutoRotatePaused = false;

        // Zoom parameters
        const DEFAULT_CAMERA_Z = 1.8;      // Existing default distance (keep as farthest zoom-out)
        const CAMERA_MIN_Z = 1.1;          // How close you can zoom in (tweak if needed)
        const CAMERA_MAX_Z = DEFAULT_CAMERA_Z; // Clamp max to current default
        const ZOOM_STEP = 0.1;             // Base step for wheel zoom adjustments
        let pinchStartDistance = null;
        let pinchStartZ = null;

        function init() {
            try {
                // Scene
                scene = new THREE.Scene();

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = DEFAULT_CAMERA_Z; // Closer to make globe larger

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0); // Transparent background
                document.body.appendChild(renderer.domElement);
                // Allow us to prevent default touch gestures for custom pinch zoom
                renderer.domElement.style.touchAction = 'none';

                // Globe geometry
                const geometry = new THREE.SphereGeometry(1, 64, 64);

                // Earth texture - try multiple paths
                const textureLoader = new THREE.TextureLoader();

                textureLoader.load(
                    '../assets/images/earth_texture.jpg',
                    function(texture) {
                        // Material
                        const material = new THREE.MeshPhongMaterial({
                            map: texture,
                            transparent: true,
                            opacity: 0.9
                        });

                        // Mesh
                        globe = new THREE.Mesh(geometry, material);
                        scene.add(globe);

                        // Set initial tilt for better orbit visibility
                        globe.rotation.x = 0.3;

                        // Cloud layer
                        const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
                        textureLoader.load(
                            'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
                            function(cloudTexture) {
                                const cloudMaterial = new THREE.MeshLambertMaterial({
                                    map: cloudTexture,
                                    transparent: true,
                                    opacity: 0.8,
                                    alphaMap: cloudTexture
                                });
                                const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                                clouds.name = 'clouds';
                                globe.add(clouds);
                                console.log("Cloud layer added");
                            },
                            undefined,
                            function(error) {
                                console.error("Error loading cloud texture:", error);
                            }
                        );

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(1, 1, 1);
                        scene.add(directionalLight);

                        // Start animation
                        animate();
                    },
                    function(progress) {
                        // Loading progress
                    },
                    function(error) {
                        console.error("Error loading texture:", error);
                        // Fallback: create globe without texture
                        const material = new THREE.MeshPhongMaterial({
                            color: 0x2233ff,
                            transparent: true,
                            opacity: 0.9
                        });

                        globe = new THREE.Mesh(geometry, material);
                        scene.add(globe);

                        // Set initial tilt for better orbit visibility
                        globe.rotation.x = 0.3;

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(1, 1, 1);
                        scene.add(directionalLight);

                        animate();
                    }
                );

                // Controls
                controls = {
                    autoRotate: true,
                    autoRotateSpeed: -0.3,
                    enableZoom: true,
                    enablePan: false,
                    enableRotate: true
                };

                // Handle window resize
                window.addEventListener('resize', onWindowResize, false);
                // Mouse wheel zoom (clamped so you can't zoom out past default)
                renderer.domElement.addEventListener('wheel', onWheelZoom, { passive: false });
                // Touch pinch zoom support
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                console.log("Event listeners added");

            } catch (error) {
                console.error("Error during initialization:", error);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function clampCameraZ(z) {
            return Math.max(CAMERA_MIN_Z, Math.min(CAMERA_MAX_Z, z));
        }

        function onWheelZoom(event) {
            // Prevent page/system scrolling
            event.preventDefault();
            if (!camera) return;
            // Normalize wheel delta: negative => zoom in; positive => zoom out
            const delta = Math.sign(event.deltaY);
            let newZ = camera.position.z + (delta * ZOOM_STEP);
            newZ = clampCameraZ(newZ);
            camera.position.z = newZ;
        }

        function distanceBetweenTouches(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.hypot(dx, dy);
        }

        function onTouchStart(event) {
            if (event.touches && event.touches.length === 2) {
                event.preventDefault();
                pinchStartDistance = distanceBetweenTouches(event.touches[0], event.touches[1]);
                pinchStartZ = camera ? camera.position.z : null;
            }
        }

        function onTouchMove(event) {
            if (event.touches && event.touches.length === 2 && pinchStartDistance && pinchStartZ != null) {
                event.preventDefault();
                const currentDistance = distanceBetweenTouches(event.touches[0], event.touches[1]);
                if (currentDistance > 0) {
                    // Ratio > 1 means fingers moved apart (zoom in)
                    const ratio = pinchStartDistance / currentDistance;
                    // Map ratio to z change around the start z
                    let targetZ = pinchStartZ * ratio;
                    // Ease the effect to avoid too aggressive zooming
                    targetZ = pinchStartZ + (targetZ - pinchStartZ) * 0.5;
                    camera.position.z = clampCameraZ(targetZ);
                }
            }
        }

        function onTouchEnd(event) {
            if (!event.touches || event.touches.length < 2) {
                pinchStartDistance = null;
                pinchStartZ = null;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (globe) {
                if (isInMomentum) {
                    // Apply momentum directly in the same frame of reference it was recorded
                    // (we bake orientation into momentum at capture time to avoid post-release flips)
                    globe.rotation.y += momentumX;
                    globe.rotation.x += momentumY;

                    // Decay momentum
                    momentumX *= 0.95; // Friction/damping
                    momentumY *= 0.95;

                    // Check if momentum is low enough to return to auto-rotation
                    if (Math.abs(momentumX) < 0.0001 && Math.abs(momentumY) < 0.0001) {
                        isInMomentum = false;
                        momentumX = 0;
                        momentumY = 0;
                    }
                } else if (controls && controls.autoRotate && !isAutoRotatePaused) {
                    // Normal auto-rotation (only if not paused)
                    globe.rotation.y += controls.autoRotateSpeed * 0.01;
                }
            }

            // Rotate clouds slower than the globe
            const clouds = scene.getObjectByName('clouds');
            if (clouds) {
                clouds.rotation.y += 0.0005;
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        function updateTrajectory(trajectoryData) {            // Remove existing trajectory line
            if (trajectoryLine) {
                if (globe) globe.remove(trajectoryLine);
                scene.remove(trajectoryLine);
                trajectoryLine.geometry.dispose();
                trajectoryLine.material.dispose();
                console.log("Removed existing trajectory");
            }

            // Remove existing launch marker
            if (launchMarker) {
                if (globe) globe.remove(launchMarker);
                scene.remove(launchMarker);
                launchMarker.geometry.dispose();
                launchMarker.material.dispose();
                console.log("Removed existing launch marker");
            }

            if (!trajectoryData || !trajectoryData.trajectory || trajectoryData.trajectory.length < 2) {
                console.log("No valid trajectory data");
                return;
            }

            console.log("Creating trajectory with", trajectoryData.trajectory.length, "points");
            console.log("Orbit path present:", !!trajectoryData.orbit_path, "with", trajectoryData.orbit_path ? trajectoryData.orbit_path.length : 0, "points");

            try {
                // Create trajectory points from the curved lat/lon data
                const points = [];

                trajectoryData.trajectory.forEach((point, index) => {
                    // Convert lat/lon to 3D coordinates on sphere with subtle arc height
                    const phi = (90 - point.lat) * (Math.PI / 180);
                    const theta = (point.lon + 180) * (Math.PI / 180);

                    // Add subtle height variation for visual effect
                    const progress = index / (trajectoryData.trajectory.length - 1);
                    const baseRadius = 1.01; // Slightly above surface for visual separation
                    const arcHeight = 0.03 * Math.sin(progress * Math.PI); // Very subtle arc
                    const radius = baseRadius + arcHeight;

                    const x = -(radius * Math.sin(phi) * Math.cos(theta));
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    const y = radius * Math.cos(phi);

                    points.push(new THREE.Vector3(x, y, z));
                });

                console.log("Created", points.length, "3D points");

                // Create trajectory geometry and material
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0xff4444,
                    linewidth: 3,
                    transparent: true,
                    opacity: 0.8
                });

                // Create trajectory line
                trajectoryLine = new THREE.Line(geometry, material);

                // Add trajectory as a child of the globe so it rotates with it
                if (globe) {
                    globe.add(trajectoryLine);
                    console.log("Trajectory line added as child of globe");
                } else {
                    scene.add(trajectoryLine);
                    console.log("Trajectory line added to scene (globe not available)");
                }

                // Removed launch site red dot marker per request; keep only the trajectory line

                // Remove previous orbit line if it exists
                if (window.currentOrbitLine) {
                    if (globe) globe.remove(window.currentOrbitLine);
                    scene.remove(window.currentOrbitLine);
                    window.currentOrbitLine.geometry.dispose();
                    window.currentOrbitLine.material.dispose();
                    window.currentOrbitLine = null;
                    console.log("Removed existing orbit line");
                }

                // Draw orbital path if present
                if (trajectoryData.orbit_path && trajectoryData.orbit_path.length > 2) {
                    console.log("Rendering orbit path with", trajectoryData.orbit_path.length, "points");

                    const orbitPoints = [];
                    trajectoryData.orbit_path.forEach((point, index) => {
                        const phi = (90 - point.lat) * (Math.PI / 180);
                        const theta = (point.lon + 180) * (Math.PI / 180);
                        // Keep orbit at a slightly higher radius for visibility
                        const radius = 1.04;
                        const x = -(radius * Math.sin(phi) * Math.cos(theta));
                        const z = radius * Math.sin(phi) * Math.sin(theta);
                        const y = radius * Math.cos(phi);
                        orbitPoints.push(new THREE.Vector3(x, y, z));
                    });
                    // Use LineSegments for dashed effect
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                    const orbitMaterial = new THREE.LineDashedMaterial({
                        color: 0x00ffff,
                        linewidth: 2,
                        dashSize: 0.03,
                        gapSize: 0.02,
                        transparent: true,
                        opacity: 0.7
                    });
                    const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
                    orbitLine.computeLineDistances();
                    if (globe) {
                        globe.add(orbitLine);
                    } else {
                        scene.add(orbitLine);
                    }
                    window.currentOrbitLine = orbitLine;
                    console.log("Orbit line added");
                }

                // Force a render
                renderer.render(scene, camera);
                console.log("Forced render");

            } catch (error) {
                console.error("Error in updateTrajectory:", error);
            }
        }

        // Initialize and start animation
        console.log("Starting initialization...");
        init();

        // Expose functions to Qt
        window.updateTrajectory = updateTrajectory;

        // Make globe interactive
        let isMouseDown = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            isInMomentum = false; // Stop momentum when user takes control
            momentumX = 0;
            momentumY = 0;
            lastTime = Date.now();
            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        document.addEventListener('mousemove', (event) => {
            if (!isMouseDown) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            // Adjust y-rotation direction based on globe orientation to prevent reversal when upside down
            const yDirection = Math.cos(globe.rotation.x) > 0 ? 1 : -1;

            // Track velocity for momentum (bake in current orientation)
            if (deltaTime > 0) {
                momentumX = (deltaX * yDirection) / deltaTime * 0.1; // Scale for smooth momentum
                momentumY = (deltaY) / deltaTime * 0.1;
            }

            globe.rotation.y += deltaX * 0.005 * yDirection;
            globe.rotation.x += deltaY * 0.005;

            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
            isInMomentum = true; // Start momentum mode
        });

        // Touch support for mobile
        document.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                isMouseDown = true;
                isInMomentum = false; // Stop momentum when user takes control
                momentumX = 0;
                momentumY = 0;
                lastTime = Date.now();
                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
        });

        document.addEventListener('touchmove', (event) => {
            if (!isMouseDown || event.touches.length !== 1) return;

            event.preventDefault();

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;

            // Adjust y-rotation direction based on globe orientation to prevent reversal when upside down
            const yDirection = Math.cos(globe.rotation.x) > 0 ? 1 : -1;

            // Track velocity for momentum (bake in current orientation)
            if (deltaTime > 0) {
                momentumX = (deltaX * yDirection) / deltaTime * 0.1;
                momentumY = (deltaY) / deltaTime * 0.1;
            }

            globe.rotation.y += deltaX * 0.005 * yDirection;
            globe.rotation.x += deltaY * 0.005;

            previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }, { passive: false });

        document.addEventListener('touchend', () => {
            isMouseDown = false;
            isInMomentum = true; // Start momentum mode
        });

        // Play/Pause button functionality
        document.getElementById('playPauseBtn').addEventListener('click', () => {
            isAutoRotatePaused = !isAutoRotatePaused;
            const button = document.getElementById('playPauseBtn');
            const icon = button.querySelector('i');
            if (isAutoRotatePaused) {
                icon.className = 'fas fa-play';
            } else {
                icon.className = 'fas fa-pause';
            }
        });
    </script>
</body>
</html>