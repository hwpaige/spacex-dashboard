<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth Globe</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
            color: white;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #playPauseBtn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            /* Move to bottom left */
            background: transparent;
            /* Graph button style: transparent */
            color: rgba(255, 255, 255, 0.7);
            /* Subtle white */
            border: none;
            /* No border */
            padding: 8px;
            font-size: 18px;
            /* Slightly larger icon */
            cursor: pointer;
            transition: color 0.2s;
            z-index: 1000;
        }

        #playPauseBtn:hover {
            background: transparent;
            color: white;
            /* Bright white on hover */
        }

        /* Light Mode Styles */
        body.light-mode #playPauseBtn {
            color: rgba(0, 0, 0, 0.7);
        }

        body.light-mode #playPauseBtn:hover {
            color: black;
        }

        .label {
            position: absolute;
            color: white;
            padding: 2px 6px;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            font-size: 9px;
            white-space: nowrap;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            font-weight: 600;
            display: none;
            align-items: center;
            z-index: 100;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .label-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #00ffff;
            border: 1px solid white;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(0, 255, 255, 0.8);
            pointer-events: none;
            display: none;
            z-index: 101;
        }

        .label-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(to right, rgba(255,255,255,0.8), rgba(255,255,255,0.1));
            pointer-events: none;
            display: none;
            z-index: 99;
            transform-origin: left center;
        }

        #labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
    </style>
    <script>
        // Lightweight loader that ensures THREE is available even if we started offline.
        // We avoid hard-failing when there's no network at boot and retry when it comes back.
        (function () {
            var attempts = 0;
            function injectThree(onReady) {
                if (window.THREE) { onReady && onReady(); return; }
                attempts++;
                try {
                    var s = document.createElement('script');
                    // Alternate between local and CDN every 2 attempts
                    if (attempts % 2 === 1) {
                        s.src = 'three.min.js';
                    } else {
                        s.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
                    }
                    s.async = true;
                    s.onload = function () { onReady && onReady(); };
                    s.onerror = function () {
                        // Retry shortly; also wait for online event
                        var delay = attempts > 5 ? 10000 : 4000;
                        setTimeout(function () { injectThree(onReady); }, delay);
                    };
                    document.head.appendChild(s);
                } catch (e) {
                    setTimeout(function () { injectThree(onReady); }, 4000);
                }
            }
            // Expose a boot function used at the bottom of the file
            window.__ensureThreeAndBoot = function (cb) {
                if (window.THREE) { cb && cb(); return; }
                injectThree(cb);
                // Also try again when network comes online
                window.addEventListener('online', function () { injectThree(cb); }, { once: true });
            };
        })();
    </script>
</head>

<body>
    <div id="labels-container"></div>
    <button id="playPauseBtn"><i class="fas fa-play"></i></button>
    <script>
        let scene, camera, renderer, globe, controls, trajectoryGroup, launchMarker;
        let cloudUniforms, cloudMaterial, loadCloudTextureFunc;
        
        const PLUME_VERTEX_SHADER = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const PLUME_FRAGMENT_SHADER = `
            uniform float time;
            uniform vec3 colorCore;
            uniform vec3 colorOuter;
            varying vec2 vUv;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                float d = vUv.y; // 1 at tip (nozzle), 0 at base (far end)
                
                // Turbulence
                float t = time * 25.0;
                float noise = hash(vUv * 5.0 + vec2(0.0, -t * 0.05)) * 0.15;
                noise += hash(vUv * 10.0 + vec2(0.0, -t * 0.1)) * 0.05;
                
                // Shape: bright core that fades out
                float core = pow(d, 2.5); // Sharp fade from nozzle
                float alpha = core * (0.8 + noise);
                
                // Edge softness (vUv.x is 0..1 around)
                float edge = sin(vUv.x * 3.14159);
                alpha *= pow(edge, 0.4);

                // Gradient
                vec3 color = mix(colorOuter, colorCore, core);
                
                // Mach disk simulation (subtle bright pulses along the length)
                float mach = sin(d * 30.0 - time * 25.0) * 0.5 + 0.5;
                color += colorCore * pow(mach, 8.0) * core * 0.4;
                
                // Flicker pulse
                color *= (0.85 + 0.15 * sin(time * 50.0));

                gl_FragColor = vec4(color, alpha * 0.9);
            }
        `;

        let annotations = []; // Array of {name, lat, lon, element, position}
        let activeCurves = []; // Array of curves for animation
        let __startTime = performance.now();
        let __lastRenderTs = performance.now();
        let __lastResumeLogTs = performance.now();
        let momentumX = 0, momentumY = 0;
        let isInMomentum = false;
        let isMouseDown = false;
        let lastTime = Date.now();
        let isAutoRotatePaused = true; // Start paused
        // Distinguish between user-initiated pause and system-initiated pause (e.g., during app/network events)
        let userPaused = true; // Start paused
        let systemPaused = false;
        let pendingSystemResume = false; // set when resume is requested during active interaction
        // Explicit auto spin enable independent of OrbitControls (more robust on Qt WebEngine)
        let autoSpinEnabled = true;
        // Track if the user is actively interacting (mouse down or any touch contact)
        // This is used to prevent auto-rotation from starting/resuming while touching.
        let userInteracting = false;
        // Track active pointer contacts (helps on Linux/Qt where pointer events may be used)
        let activePointers = 0;
        // Track gesture mode to avoid mixing pinch and drag states
        // Values: 'none' | 'drag' | 'pinch'
        let touchMode = 'none';
        // Track last deltas to decide whether to start momentum on release
        let lastDeltaX = 0, lastDeltaY = 0;
        let lastMoveTimeMs = 0;
        // Drag deadzone and pinch tracking
        const DRAG_DEADZONE_PX = 8;           // ignore tiny movements
        const RECENT_MS_THRESHOLD = 110;      // last movement must be recent
        const MIN_RELEASE_VELOCITY = 0.002;   // minimum velocity to start inertia
        let cumulativeDragDistance = 0;       // reset per-drag
        let hadPinchSinceLastDrag = false;    // cancels inertia if pinch occurred

        // Short-window velocity averaging to avoid "opposite recoil"
        const VELOCITY_WINDOW_MS = 140;       // average last ~140 ms of motion
        let recentMoves = [];                 // entries: { t, dt, dxAdj, dy }

        function resetRecentMoves() { recentMoves = []; }
        function pushRecentMove(dx, dy, yDirection, dt, now) {
            if (!isFinite(dt) || dt <= 0) return;
            const entry = {
                t: now,
                dt: dt,
                dxAdj: dx * yDirection,
                dy: dy
            };
            recentMoves.push(entry);
            // Trim old entries beyond window
            const cutoff = now - VELOCITY_WINDOW_MS;
            while (recentMoves.length && recentMoves[0].t < cutoff) {
                recentMoves.shift();
            }
            // Keep list reasonably small (safety cap)
            if (recentMoves.length > 20) recentMoves.splice(0, recentMoves.length - 20);
        }
        function getAveragedVelocity() {
            if (!recentMoves.length) return { vx: 0, vy: 0, mag: 0 };
            let sumDx = 0, sumDy = 0, sumDt = 0;
            for (const m of recentMoves) {
                sumDx += m.dxAdj;
                sumDy += m.dy;
                sumDt += m.dt;
            }
            if (sumDt <= 0) return { vx: 0, vy: 0, mag: 0 };
            // Scale to match previous tuning (0.1 factor used before)
            const vx = (sumDx / sumDt) * 0.1;
            const vy = (sumDy / sumDt) * 0.1;
            const mag = Math.abs(vx) + Math.abs(vy);
            return { vx, vy, mag };
        }

        // Zoom parameters
        const DEFAULT_CAMERA_Z = 1.8;      // Existing default distance (keep as farthest zoom-out)
        const CAMERA_MIN_Z = 1.1;          // How close you can zoom in (tweak if needed)
        const CAMERA_MAX_Z = DEFAULT_CAMERA_Z; // Clamp max to current default
        const ZOOM_STEP = 0.1;             // Base step for wheel zoom adjustments
        let pinchStartDistance = null;
        let pinchStartZ = null;

        function init() {
            try {
                // Scene
                scene = new THREE.Scene();

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = DEFAULT_CAMERA_Z; // Closer to make globe larger

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setPixelRatio(window.devicePixelRatio); // Sharpness on high-DPI screens
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0); // Transparent background
                document.body.appendChild(renderer.domElement);
                // Allow us to prevent default touch gestures for custom pinch zoom
                renderer.domElement.style.touchAction = 'none';

                // Globe geometry
                const geometry = new THREE.SphereGeometry(1, 64, 64);

                // Earth texture - try multiple paths
                const textureLoader = new THREE.TextureLoader();

                function loadEarthTexture(hdPath, sdPath, onComplete) {
                    // Optimized Tiled HD loading (bypasses Pi 4096px hardware limit)
                    // Configurable grid: 2x1 (Med), 4x2 (High), 6x3 (Ultra)
                    // Make sure these match the output of tools/tile_globe_texture.py
                    const tilesX = 4;
                    const tilesY = 2;
                    const firstTilePath = '../assets/images/tiles/tile_0_0.jpg';

                    textureLoader.load(firstTilePath,
                        function (firstTex) {
                            console.log("Found tiled textures, loading set...");
                            const tileTextures = new Array(tilesX * tilesY);
                            const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                            firstTex.anisotropy = maxAnisotropy;
                            tileTextures[0] = firstTex;

                            let loadedCount = 1;
                            const totalTiles = tilesX * tilesY;

                            if (totalTiles === 1) {
                                onComplete(tileTextures, tilesX, tilesY);
                                return;
                            }

                            for (let i = 1; i < totalTiles; i++) {
                                const tx = i % tilesX;
                                const ty = Math.floor(i / tilesX);
                                const tilePath = `../assets/images/tiles/tile_${tx}_${ty}.jpg`;

                                textureLoader.load(tilePath,
                                    function (tex) {
                                        tex.anisotropy = maxAnisotropy;
                                        tileTextures[i] = tex;
                                        loadedCount++;
                                        if (loadedCount === totalTiles) {
                                            onComplete(tileTextures, tilesX, tilesY);
                                        }
                                    },
                                    undefined,
                                    function () {
                                        console.warn("Failed to load some tiles, falling back to single HD");
                                        loadSingleHD();
                                    }
                                );
                            }
                        },
                        undefined,
                        function () {
                            console.log("Tiled textures not found, trying single HD...");
                            loadSingleHD();
                        }
                    );

                    function loadSingleHD() {
                        // Try HD
                        textureLoader.load(hdPath,
                            function (texture) {
                                console.log("Loaded HD Earth texture");
                                const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                                texture.anisotropy = maxAnisotropy;
                                onComplete(texture);
                            },
                            undefined,
                            function (err) {
                                console.log("HD texture not found, trying SD...");
                                // Try SD
                                textureLoader.load(sdPath,
                                    function (texture) {
                                        console.log("Loaded SD Earth texture");
                                        const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                                        texture.anisotropy = maxAnisotropy;
                                        onComplete(texture);
                                    },
                                    undefined,
                                    function (err2) {
                                        console.log("SD texture not found, falling back to procedural");
                                        onComplete(null);
                                    }
                                );
                            }
                        );
                    }
                }

                loadEarthTexture(
                    '../assets/images/earth_texture_hd.jpg',
                    '../assets/images/earth_texture.jpg',
                    function (texture, tX, tY) {
                        if (Array.isArray(texture)) {
                            // Tiled mode
                            globe = new THREE.Group();
                            const tilesX = tX;
                            const tilesY = tY;

                            for (let y = 0; y < tilesY; y++) {
                                for (let x = 0; x < tilesX; x++) {
                                    const phiStart = (x / tilesX) * Math.PI * 2;
                                    const phiLength = (1 / tilesX) * Math.PI * 2;
                                    const thetaStart = (y / tilesY) * Math.PI;
                                    const thetaLength = (1 / tilesY) * Math.PI;

                                    const tileGeom = new THREE.SphereGeometry(1, 64 / tilesX, 64 / tilesY, phiStart, phiLength, thetaStart, thetaLength);
                                    const tileMat = new THREE.MeshPhongMaterial({
                                        map: texture[y * tilesX + x],
                                        transparent: true,
                                        opacity: 0.9
                                    });
                                    const tileMesh = new THREE.Mesh(tileGeom, tileMat);
                                    globe.add(tileMesh);
                                }
                            }
                        } else {
                            // Single texture mode
                            let material;
                            if (texture) {
                                material = new THREE.MeshPhongMaterial({
                                    map: texture,
                                    transparent: true,
                                    opacity: 0.9
                                });
                            } else {
                                // Fallback: create globe without texture
                                material = new THREE.MeshPhongMaterial({
                                    color: 0x2233ff,
                                    transparent: true,
                                    opacity: 0.9
                                });
                            }
                            globe = new THREE.Mesh(geometry, material);
                        }

                        scene.add(globe);

                        // Set initial tilt for better orbit visibility
                        globe.rotation.x = 0.6;
                        // Focus on US (approx 0.5 radians: 4.7 was Africa, increasing moves West)
                        globe.rotation.y = 0.5;

                        // Cloud layer (Shader-based)
                        const cloudGeometry = new THREE.SphereGeometry(1.01, 80, 80);
                        const cloudVertexShader = `
                            precision mediump float;
                            varying vec2 vUv;
                            varying vec3 vNormal;
                            varying vec3 vViewPosition;
                            void main() {
                                vUv = uv;
                                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                                vNormal = normalize(normalMatrix * normal);
                                vViewPosition = -mvPosition.xyz;
                                gl_Position = projectionMatrix * mvPosition;
                            }
                        `;
                        const cloudFragmentShader = `
                            precision mediump float;
                            uniform sampler2D cloudTexture;
                            uniform float time;
                            uniform bool hasTexture;
                            varying vec2 vUv;
                            varying vec3 vNormal;
                            varying vec3 vViewPosition;

                            // 2D Noise function for convection/swirl effect
                            vec2 hash(vec2 p) {
                                p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
                                return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
                            }

                            float noise(vec2 p) {
                                const float K1 = 0.366025404; // (sqrt(3)-1)/2;
                                const float K2 = 0.211324865; // (3-sqrt(3))/6;
                                vec2 i = floor(p + (p.x + p.y) * K1);
                                vec2 a = p - i + (i.x + i.y) * K2;
                                vec2 o = (a.x > a.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                                vec2 b = a - o + K2;
                                vec2 c = a - 1.0 + 2.0 * K2;
                                vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);
                                vec3 n = h * h * h * h * vec3(dot(a, hash(i + 0.0)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));
                                return dot(n, vec3(70.0));
                            }

                            // Optimized multi-octave noise for Pi (fBm)
                            float fbm(vec2 p) {
                                float f = 0.0;
                                float amp = 0.5;
                                for (int i = 0; i < 6; i++) {
                                    f += amp * noise(p);
                                    p *= 2.1;
                                    amp *= 0.48;
                                }
                                return f;
                            }

                            void main() {
                                // Multi-scale distortion for organic movement
                                float n1 = noise(vUv * 4.0 + time * 0.04);
                                float n2 = noise(vUv * 8.0 - time * 0.07);
                                // Micro-swirls for high-resolution texture feel
                                float n3 = noise(vUv * 16.0 + time * 0.1);
                                vec2 distortedUv = vUv + vec2(n1 * 0.03 + n3 * 0.005, n2 * 0.02);
                                
                                vec4 texColor;
                                vec4 texColor2;
                                
                                if (hasTexture) {
                                    texColor = texture2D(cloudTexture, distortedUv);
                                    // High-frequency detail injection for texture mode
                                    float detail = fbm(vUv * 25.0 - time * 0.05) * 0.25;
                                    texColor.a *= (1.0 + detail);
                                    
                                    float n3 = noise(vUv * 6.0 - time * 0.05);
                                    texColor2 = texture2D(cloudTexture, vUv + vec2(n3 * 0.015, 0.0));
                                } else {
                            // High-detail procedural fallback using fBm
                                    // Layer 1: Large slow structures (low freq, high amp)
                                    float layer1 = fbm(vUv * 4.8 + time * 0.025) * 0.65 + 0.35;
                                    // Layer 2: Medium faster wisps (med freq, med amp)
                                    float layer2 = fbm(vUv * 10.5 - time * 0.07) * 0.55 + 0.45;
                                    // Layer 3: High-freq detail (micro-noise)
                                    float layer3 = fbm(vUv * 45.0 + time * 0.1) * 0.45 + 0.55;
                                    
                                    // Complex blending for organic structure
                                    float combined = mix(layer1, layer2, 0.45);
                                    combined = combined * 0.6 + layer3 * 0.4;
                                    
                                    // Dynamic "sculpting" of cloud edges for high-res look
                                    float cloudAlpha = smoothstep(0.4, 0.72, combined);
                                    
                                    // Secondary detail for "fluffiness" and internal structure
                                    float detail = fbm(vUv * 30.0 + time * 0.04);
                                    cloudAlpha += detail * 0.2 * cloudAlpha;
                                    
                                    vec3 cloudColor = vec3(1.0, 1.0, 1.0);
                                    
                                    // Add "shadow" effect for depth (Simulated lighting)
                                    float shadow = fbm(vUv * 6.0 + time * 0.04 + 0.15);
                                    cloudColor *= (0.8 + 0.2 * shadow);
                                    
                                    texColor = vec4(cloudColor, cloudAlpha * 0.95);
                                    
                                    // Second wispier layer for depth and atmospheric haze
                                    float wisp = fbm(vUv * 18.0 + time * 0.05) * 0.5 + 0.5;
                                    wisp = smoothstep(0.4, 0.88, wisp);
                                    texColor2 = vec4(cloudColor, wisp * 0.45);
                                }
                                
                                vec4 finalColor = mix(texColor, texColor2, 0.3);
                                if (hasTexture) {
                                    finalColor.a *= 0.8; 
                                }

                                // Fresnel rim effect for atmosphere-like clouds
                                float fresnel = pow(1.0 - max(dot(normalize(vNormal), normalize(vViewPosition)), 0.0), 3.0);
                                finalColor.a *= (0.8 + fresnel * 0.4);
                                
                                gl_FragColor = finalColor;
                            }
                        `;

                        cloudUniforms = {
                            cloudTexture: { value: null },
                            time: { value: 0.0 },
                            hasTexture: { value: false }
                        };

                        cloudMaterial = new THREE.ShaderMaterial({
                            uniforms: cloudUniforms,
                            vertexShader: cloudVertexShader,
                            fragmentShader: cloudFragmentShader,
                            transparent: true,
                            depthWrite: false // Good for transparency layers
                        });

                        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                        clouds.name = 'clouds';
                        globe.add(clouds);
                        
                        // Debug log for cloud creation
                        console.log("Cloud layer created and added to globe");

                        loadCloudTextureFunc = function() {
                            const cloudSources = [
                                '../assets/images/earth_clouds_1024.png',
                                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_clouds_1024.png',
                                'https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/planets/earth_clouds_1024.png'
                            ];

                            let sourceIndex = 0;

                            function tryNext() {
                                if (sourceIndex >= cloudSources.length) {
                                    console.warn("All cloud texture sources failed, using procedural fallback");
                                    cloudUniforms.hasTexture.value = false;
                                    cloudMaterial.needsUpdate = true;
                                    return;
                                }

                                const src = cloudSources[sourceIndex];
                                console.log("Attempting to load cloud texture from:", src);
                                textureLoader.load(
                                    src,
                                    function (cloudTexture) {
                                        cloudTexture.wrapS = cloudTexture.wrapT = THREE.RepeatWrapping;
                                        cloudUniforms.cloudTexture.value = cloudTexture;
                                        cloudUniforms.hasTexture.value = true;
                                        cloudMaterial.needsUpdate = true;
                                        console.log("Cloud layer texture loaded successfully from:", src);
                                    },
                                    undefined,
                                    function (error) {
                                        console.warn("Failed to load cloud texture from:", src);
                                        sourceIndex++;
                                        tryNext();
                                    }
                                );
                            }

                            tryNext();
                        };

                        loadCloudTextureFunc();

                        // Lighting
                        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                        scene.add(ambientLight);

                        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                        directionalLight.position.set(1, 1, 1);
                        scene.add(directionalLight);

                        // Add Permanent Droneships
                        console.log("Adding permanent droneships to East and West coasts...");
                        const droneshipLocations = [
                            { name: 'OCISLY (East)', lat: 28.45, lon: -79.67 }, // Atlantic
                            { name: 'JRTI (West)', lat: 33.72, lon: -119.50 }   // Pacific
                        ];

                        droneshipLocations.forEach(loc => {
                            const ship = createDroneshipModel();
                            const phi = (90 - loc.lat) * (Math.PI / 180);
                            const theta = (loc.lon + 180) * (Math.PI / 180);
                            const radius = 1.002;
                            const x = -(radius * Math.sin(phi) * Math.cos(theta));
                            const z = radius * Math.sin(phi) * Math.sin(theta);
                            const y = radius * Math.cos(phi);
                            const pos = new THREE.Vector3(x, y, z);
                            
                            ship.position.copy(pos);
                            ship.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), pos.clone().normalize());
                            globe.add(ship);
                        });

                        // Start animation
                        animate();
                    }
                );

                // Controls
                controls = {
                    autoRotate: true,
                    autoRotateSpeed: -0.3,
                    enableZoom: true,
                    enablePan: false,
                    enableRotate: true
                };

                // Handle window resize
                window.addEventListener('resize', onWindowResize, false);
                // Mouse wheel zoom (clamped so you can't zoom out past default)
                renderer.domElement.addEventListener('wheel', onWheelZoom, { passive: false });
                // Touch pinch zoom support
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                console.log("Event listeners added");

                // Pointer event fallbacks (Linux/Qt WebEngine often routes touch via pointer events)
                // We only count non-mouse pointers here to avoid double-handling regular mouse drags.
                // Moving these into init ensures renderer.domElement is available safely.
                renderer.domElement.addEventListener('pointerdown', (e) => {
                    if (e && e.pointerType && e.pointerType !== 'mouse') {
                        activePointers++;
                        userInteracting = true;
                    }
                });
                document.addEventListener('pointerup', (e) => {
                    if (e && e.pointerType && e.pointerType !== 'mouse') {
                        activePointers = Math.max(0, activePointers - 1);
                        if (activePointers === 0 && !isMouseDown) {
                            userInteracting = false;
                        }
                    }
                });
                document.addEventListener('pointercancel', (e) => {
                    if (e && e.pointerType && e.pointerType !== 'mouse') {
                        activePointers = Math.max(0, activePointers - 1);
                        if (activePointers === 0 && !isMouseDown) {
                            userInteracting = false;
                        }
                    }
                });

                // Disable in-page context menu (right-click/long-press)
                try { document.addEventListener('contextmenu', function (e) { e.preventDefault(); }, { passive: false }); } catch (_e) { }

            } catch (error) {
                console.error("Error during initialization:", error);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function clampCameraZ(z) {
            return Math.max(CAMERA_MIN_Z, Math.min(CAMERA_MAX_Z, z));
        }

        function onWheelZoom(event) {
            // Prevent page/system scrolling
            event.preventDefault();
            if (!camera) return;
            // Normalize wheel delta: negative => zoom in; positive => zoom out
            const delta = Math.sign(event.deltaY);
            let newZ = camera.position.z + (delta * ZOOM_STEP);
            newZ = clampCameraZ(newZ);
            camera.position.z = newZ;
        }

        function clampRotationX() {
            // Avoid flipping the globe which can invert drag directions
            const maxTilt = Math.PI / 2 - 0.05; // small margin from 90Â°
            if (!globe) return;
            if (globe.rotation.x > maxTilt) globe.rotation.x = maxTilt;
            if (globe.rotation.x < -maxTilt) globe.rotation.x = -maxTilt;
        }

        function distanceBetweenTouches(t1, t2) {
            const dx = t1.clientX - t2.clientX;
            const dy = t1.clientY - t2.clientY;
            return Math.hypot(dx, dy);
        }

        function onTouchStart(event) {
            if (event.touches && event.touches.length === 2) {
                event.preventDefault();
                pinchStartDistance = distanceBetweenTouches(event.touches[0], event.touches[1]);
                pinchStartZ = camera ? camera.position.z : null;
                // Enter pinch mode and cancel any drag momentum state
                touchMode = 'pinch';
                isInMomentum = false;
                momentumX = 0; momentumY = 0;
                // Ensure drag state is not considered active
                isMouseDown = false;
                userInteracting = true;
            }
        }

        function onTouchMove(event) {
            if (event.touches && event.touches.length === 2 && pinchStartDistance && pinchStartZ != null) {
                event.preventDefault();
                const currentDistance = distanceBetweenTouches(event.touches[0], event.touches[1]);
                if (currentDistance > 0) {
                    // Ratio > 1 means fingers moved apart (zoom in)
                    const ratio = pinchStartDistance / currentDistance;
                    // Map ratio to z change around the start z
                    let targetZ = pinchStartZ * ratio;
                    // Ease the effect to avoid too aggressive zooming
                    targetZ = pinchStartZ + (targetZ - pinchStartZ) * 0.5;
                    camera.position.z = clampCameraZ(targetZ);
                }
            }
        }

        function onTouchEnd(event) {
            if (!event.touches || event.touches.length < 2) {
                pinchStartDistance = null;
                pinchStartZ = null;
                // Leave pinch mode; do not start momentum here (handled in document touchend for drag)
                if (touchMode === 'pinch' && (!event.touches || event.touches.length === 0)) {
                    touchMode = 'none';
                }
                if (!event.touches || event.touches.length === 0) {
                    userInteracting = false;
                }
            }
        }

        function updateObjectOrientation(object, pos, tangent, isBooster, t_flip) {
            const radial = pos.clone().normalize(); // Surface normal (up)
            
            let desiredDir;
            if (isBooster) {
                if (t_flip < 0.15) {
                    // Stable Boostback Flip (Pitch only)
                    // Use binormal (perpendicular to flight path and radial) as stable rotation axis
                    const binormal = new THREE.Vector3().crossVectors(tangent, radial).normalize();
                    
                    // Fallback if tangent and radial are perfectly parallel (unlikely but possible)
                    if (binormal.lengthSq() < 0.0001) {
                        binormal.set(0, 1, 0);
                        if (Math.abs(binormal.dot(radial)) > 0.9) binormal.set(1, 0, 0);
                    }

                    const angle = (t_flip / 0.15) * Math.PI; // 0 to 180 deg
                    desiredDir = tangent.clone().applyAxisAngle(binormal, angle);
                } else {
                    // Engines-first for return
                    desiredDir = tangent.clone().negate();
                }
            } else {
                // Nose-first for main flight
                desiredDir = tangent;
            }

            // Robust look-at with radial up reference to prevent disorienting roll
            // If desiredDir and radial are parallel (vertical flight), use a stable fallback for 'up'
            const dot = Math.abs(desiredDir.dot(radial));
            let up = radial;
            if (dot > 0.999) {
                // Use a vector that is definitely not parallel to radial
                if (Math.abs(radial.y) < 0.9) {
                    up = new THREE.Vector3(0, 1, 0);
                } else {
                    up = new THREE.Vector3(1, 0, 0);
                }
            }

            const m = new THREE.Matrix4();
            m.lookAt(desiredDir, new THREE.Vector3(0,0,0), up);
            object.quaternion.setFromRotationMatrix(m);
            // Rocket model is +Y up, lookAt points +Z to target
            object.rotateX(Math.PI / 2);
        }

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const absoluteTime = (now - __startTime) / 1000.0;

            // Optimization: Skip all processing if system is paused and no interaction is happening
            if (systemPaused && !userInteracting && !isInMomentum) {
                return;
            }

            if (globe) {
                if (isInMomentum) {
                    // Apply momentum directly in the same frame of reference it was recorded
                    // (we bake orientation into momentum at capture time to avoid post-release flips)
                    globe.rotation.y += momentumX;
                    if (!window.__userRotOffset) window.__userRotOffset = 0;
                    window.__userRotOffset += momentumX;
                    
                    globe.rotation.x += momentumY;
                    clampRotationX();

                    // Decay momentum
                    // Slightly stronger damping to reduce perceived recoil
                    momentumX *= 0.93; // Friction/damping
                    momentumY *= 0.93;

                    // Check if momentum is low enough to return to auto-rotation
                    if (Math.abs(momentumX) < 0.0001 && Math.abs(momentumY) < 0.0001) {
                        isInMomentum = false;
                        momentumX = 0;
                        momentumY = 0;
                    }
                } else if (autoSpinEnabled && !userPaused && !systemPaused && !userInteracting) {
                    // Normal auto-rotation (decoupled from OrbitControls)
                    const baseSpeed = (controls && typeof controls.autoRotateSpeed === 'number') ? controls.autoRotateSpeed : 2.0;
                    // Use a separate base for auto-rotation to allow interaction to "offset" it
                    if (!window.__autoRotBase) window.__autoRotBase = 0;
                    window.__autoRotBase += baseSpeed * 0.01;
                    globe.rotation.y = window.__autoRotBase + (window.__userRotOffset || 0);
                }
            }

            // Rotate clouds slower than the globe
            const clouds = scene.getObjectByName('clouds');
            if (clouds) {
                // Cloud rotation can stay relative or use absolute time for perfect consistency
                clouds.rotation.y = absoluteTime * 0.05; 
                if (clouds.material && clouds.material.uniforms && clouds.material.uniforms.time) {
                    clouds.material.uniforms.time.value = absoluteTime;
                }
            }

            // Animate trajectory rocket models
            if (trajectoryGroup) {
                const t_main = (absoluteTime * 0.05) % 1.0; // Slower speed (was 0.15)
                
                activeCurves.forEach(ac => {
                    if (ac.curve && ac.flare) {
                        let t;
                        const t_sep = ac.t_sep || 0.2;
                        let plumeVisible = false;
                        const parts = ac.flare.parts || {};

                        if (ac.isBooster) {
                            // Booster only appears after separation
                            if (t_main < t_sep) {
                                ac.flare.visible = false;
                                return;
                            } else {
                                ac.flare.visible = true;
                                // Map t_main [t_sep, 1.0] to t [0.0, 1.0]
                                t = (t_main - t_sep) / (1.0 - t_sep);
                                
                                // Booster Burns: Boostback (start), Entry (mid), and Landing (end)
                                plumeVisible = (t < 0.12 || (t > 0.45 && t < 0.55) || t > 0.88);
                            }
                        } else {
                            // Main rocket follows t_main
                            t = t_main;
                            ac.flare.visible = true;
                            
                            // Plume on during ascent (S1) and after separation (S2)
                            plumeVisible = true;

                            // Separate stages: hide S1, interstage, and octoweb on main rocket after separation
                            // Using cached parts for perfect frame-sync
                            if (parts.stage1) parts.stage1.visible = (t < t_sep);
                            if (parts.interstage) parts.interstage.visible = (t < t_sep);
                            if (parts.octoweb) parts.octoweb.visible = (t < t_sep);
                        }

                        // Update plume animation using cached parts
                        const plumeS1 = parts.plumeS1;
                        const plumeS2 = parts.plumeS2;
                        
                        // Decide which plume to show
                        let activePlume = null;
                        if (ac.isBooster) {
                            activePlume = plumeS1;
                            if (plumeS2) plumeS2.visible = false;
                        } else {
                            if (t < t_sep) {
                                activePlume = plumeS1;
                                if (plumeS2) plumeS2.visible = false;
                            } else {
                                activePlume = plumeS2;
                                if (plumeS1) plumeS1.visible = false;
                            }
                        }

                        if (activePlume) {
                            activePlume.visible = plumeVisible;
                            if (plumeVisible) {
                                // Altitude-based expansion (simulating vacuum expansion)
                                const currentDist = ac.flare.position.length();
                                const altitudeEffect = Math.max(0, (currentDist - 1.0) * 15.0);
                                const expansion = 1.0 + Math.min(2.5, altitudeEffect);
                                
                                // Organic flicker/pulse for scale
                                const flicker = 0.95 + Math.random() * 0.1;
                                const lengthFlicker = 0.95 + Math.random() * 0.15;
                                activePlume.scale.set(expansion * flicker, lengthFlicker, expansion * flicker);

                                activePlume.traverse(child => {
                                    if (child.material && child.material.uniforms) {
                                        child.material.uniforms.time.value = absoluteTime;
                                    }
                                });
                            }
                        }

                        const pos = ac.curve.getPointAt(t);
                        ac.flare.position.copy(pos);
                        
                        // Use stable orientation helper
                        const tangent = ac.curve.getTangentAt(t).normalize();
                        updateObjectOrientation(ac.flare, pos, tangent, ac.isBooster, t);
                    }
                });
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
                updateLabels();
            }

            // Track last render timestamp for watchdog
            __lastRenderTs = now;
            
            // Periodically log animation status (every 5 seconds)
            if (now - __lastResumeLogTs > 5000) {
                console.log(`[globe] Animating: time=${absoluteTime.toFixed(2)}, systemPaused=${systemPaused}, userInteracting=${userInteracting}`);
                __lastResumeLogTs = now;
            }
        }

        function setAnnotations(locationList) {
            const container = document.getElementById('labels-container');
            container.innerHTML = '';
            annotations = [];

            if (!locationList) return;

            locationList.forEach(loc => {
                let displayName = loc.name;
                if (displayName === "Hawthorne HQ") displayName = "Hawthorne";
                if (displayName === "Kennedy Space Center") displayName = "KSC";

                const el = document.createElement('div');
                el.className = 'label';
                el.textContent = displayName;
                container.appendChild(el);

                const dot = document.createElement('div');
                dot.className = 'label-dot';
                container.appendChild(dot);

                // Convert lat/lon to 3D
                const phi = (90 - loc.lat) * (Math.PI / 180);
                const theta = (loc.lon + 180) * (Math.PI / 180);
                const radius = 1.002; // Slightly above surface
                const x = -(radius * Math.sin(phi) * Math.cos(theta));
                const z = radius * Math.sin(phi) * Math.sin(theta);
                const y = radius * Math.cos(phi);

                annotations.push({
                    name: displayName,
                    position: new THREE.Vector3(x, y, z),
                    element: el,
                    dot: dot,
                    width: 0,
                    height: 0
                });
            });
            
            // Force a quick layout measurement after a tiny delay if needed, 
            // but for now we'll just measure in updateLabels if 0.
            console.log(`Set ${annotations.length} annotations`);
        }

        window.setAnnotations = setAnnotations;

        function updateLabels() {
            if (!globe || !camera || !annotations.length) return;

            const widthHalf = window.innerWidth / 2;
            const heightHalf = window.innerHeight / 2;

            const visibleAnnos = [];

            annotations.forEach(anno => {
                const pos = anno.position.clone();
                globe.localToWorld(pos);

                // 1. Perspective Occlusion (Behind the Earth)
                const cameraToPoint = pos.clone().sub(camera.position);
                const distToPoint = cameraToPoint.length();
                const cameraToCenter = new THREE.Vector3(0, 0, 0).sub(camera.position);
                const distToCenter = cameraToCenter.length();
                
                const angle = cameraToCenter.angleTo(cameraToPoint);
                const horizonAngle = Math.asin(1.0 / distToCenter);

                if (distToPoint > distToCenter && angle > horizonAngle) {
                    anno.element.style.display = 'none';
                    if (anno.dot) anno.dot.style.display = 'none';
                    return;
                }

                // 2. Viewport Frustum / Bound check
                const screenPos = pos.clone();
                screenPos.project(camera);
                
                if (screenPos.z > 1 || Math.abs(screenPos.x) > 1.1 || Math.abs(screenPos.y) > 1.1) {
                    anno.element.style.display = 'none';
                    if (anno.dot) anno.dot.style.display = 'none';
                    return;
                }

                const x = (screenPos.x * widthHalf) + widthHalf;
                const y = -(screenPos.y * heightHalf) + heightHalf;

                anno.screenPos = { x, y, z: screenPos.z, dist: distToPoint };
                visibleAnnos.push(anno);
            });

            // Use a stable sort order (alphabetical) for consistent rendering.
            visibleAnnos.sort((a, b) => a.name.localeCompare(b.name));

            visibleAnnos.forEach(anno => {
                const el = anno.element;
                const dot = anno.dot;

                el.style.display = 'flex';
                // Higher z-index for closer labels
                el.style.zIndex = 100 + Math.floor((2.5 - anno.screenPos.dist) * 10);

                if (dot) {
                    dot.style.display = 'block';
                    dot.style.transform = `translate(-50%, -50%) translate(${anno.screenPos.x}px, ${anno.screenPos.y}px)`;
                }

                // Measure if not cached
                if (!anno.width || anno.width === 0) {
                    anno.width = el.offsetWidth;
                    anno.height = el.offsetHeight;
                }

                // Fixed position: Right of the dot
                let tx = anno.screenPos.x + 10;
                let onRight = true;
                // If not enough space on right, place on left
                if (tx + anno.width > window.innerWidth - 10) {
                    tx = anno.screenPos.x - anno.width - 10;
                    onRight = false;
                }
                // Center vertically on the dot
                let ty = anno.screenPos.y - anno.height / 2;

                el.style.transform = `translate(${tx}px, ${ty}px)`;

                // Fade based on distance
                const opacity = Math.max(0, Math.min(1, (2.2 - anno.screenPos.dist) * 2));
                el.style.opacity = opacity;
                if (dot) dot.style.opacity = opacity;
            });
        }

        function createFalcon9Model(isBooster = false) {
            const group = new THREE.Group();
            group.parts = {};
            
            // Dimensions (scaled for the globe where R=1)
            const height = 0.18; // Even more scale (was 0.12)
            const radius = 0.008; // Even more scale (was 0.005)
            
            // 1. First Stage (Main body)
            const stage1Height = height * 0.65; // Consistent 0.65 for seamless transition
            const stage1Geo = new THREE.CylinderGeometry(radius, radius, stage1Height, 12);
            const stage1Mat = new THREE.MeshPhongMaterial({ color: 0xeeeeee }); // Off-white
            const stage1 = new THREE.Mesh(stage1Geo, stage1Mat);
            stage1.name = 'stage1';
            stage1.position.y = stage1Height / 2;
            group.add(stage1);
            group.parts.stage1 = stage1;
            
            // 2. Interstage (Black part)
            const interstageHeight = height * 0.08;
            const interstageGeo = new THREE.CylinderGeometry(radius, radius, interstageHeight, 12);
            const interstageMat = new THREE.MeshPhongMaterial({ color: 0x222222 }); // Black/Dark Grey
            const interstage = new THREE.Mesh(interstageGeo, interstageMat);
            interstage.name = 'interstage';
            interstage.position.y = stage1Height + interstageHeight / 2;
            group.add(interstage);
            group.parts.interstage = interstage;

            const createPlume = (pRadius, pHeight, pName) => {
                const plumeGroup = new THREE.Group();
                plumeGroup.name = pName;
                
                // Outer plume (wider, softer orange)
                const outerPlumeGeo = new THREE.ConeGeometry(pRadius * 1.8, pHeight, 16);
                outerPlumeGeo.translate(0, -pHeight / 2, 0);
                const outerPlumeMat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        colorCore: { value: new THREE.Color(0xffaa44) },
                        colorOuter: { value: new THREE.Color(0xff4400) }
                    },
                    vertexShader: PLUME_VERTEX_SHADER,
                    fragmentShader: PLUME_FRAGMENT_SHADER,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const outerPlume = new THREE.Mesh(outerPlumeGeo, outerPlumeMat);
                plumeGroup.add(outerPlume);

                // Inner core (narrower, brighter cyan-white)
                const innerPlumeGeo = new THREE.ConeGeometry(pRadius * 0.7, pHeight * 0.8, 16);
                innerPlumeGeo.translate(0, -pHeight * 0.4, 0);
                const innerPlumeMat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        colorCore: { value: new THREE.Color(0xffffff) },
                        colorOuter: { value: new THREE.Color(0xffffaa) }
                    },
                    vertexShader: PLUME_VERTEX_SHADER,
                    fragmentShader: PLUME_FRAGMENT_SHADER,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const innerPlume = new THREE.Mesh(innerPlumeGeo, innerPlumeMat);
                plumeGroup.add(innerPlume);
                
                plumeGroup.visible = false;
                return plumeGroup;
            };
            
            if (!isBooster) {
                // 3. Second Stage
                const stage2Height = height * 0.12;
                const stage2Geo = new THREE.CylinderGeometry(radius, radius, stage2Height, 12);
                const stage2Mat = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
                const stage2 = new THREE.Mesh(stage2Geo, stage2Mat);
                stage2.name = 'stage2';
                stage2.position.y = stage1Height + interstageHeight + stage2Height / 2;
                group.add(stage2);
                group.parts.stage2 = stage2;
                
                // 4. Fairing (Ogive shape simplified as cone)
                const fairingHeight = height * 0.15;
                const fairingGeo = new THREE.CylinderGeometry(0, radius, fairingHeight, 12);
                const fairingMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee });
                const fairing = new THREE.Mesh(fairingGeo, fairingMat);
                fairing.name = 'fairing';
                fairing.position.y = stage1Height + interstageHeight + stage2Height + fairingHeight / 2;
                group.add(fairing);
                group.parts.fairing = fairing;

                // 9. Stage 2 Plume
                const plumeS2 = createPlume(radius * 0.8, height * 0.3, 'plumeS2');
                plumeS2.position.y = stage1Height + interstageHeight;
                group.add(plumeS2);
                group.parts.plumeS2 = plumeS2;
            } else {
                // 5. Grid Fins (for booster - deployed)
                const finSize = radius * 1.5;
                const finGeo = new THREE.BoxGeometry(finSize, 0.0005, finSize);
                const finMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
                for (let i = 0; i < 4; i++) {
                    const fin = new THREE.Mesh(finGeo, finMat);
                    fin.position.y = stage1Height + interstageHeight - 0.002;
                    fin.rotation.y = (i * Math.PI) / 2;
                    fin.translateZ(radius + finSize / 2);
                    group.add(fin);
                }

                // 6. Landing Legs (for booster - folded)
                const legHeight = stage1Height * 0.35;
                const legGeo = new THREE.BoxGeometry(radius * 0.4, legHeight, radius * 0.6);
                const legMat = new THREE.MeshPhongMaterial({ color: 0xdddddd });
                for (let i = 0; i < 4; i++) {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.y = legHeight / 2;
                    leg.rotation.y = (i * Math.PI) / 2 + Math.PI / 4;
                    leg.translateZ(radius + radius * 0.2);
                    group.add(leg);
                }
            }
            
            // 7. Octoweb / Engines (bottom)
            const octoHeight = height * 0.02;
            const octoGeo = new THREE.CylinderGeometry(radius, radius * 1.1, octoHeight, 12);
            const octoMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const octo = new THREE.Mesh(octoGeo, octoMat);
            octo.name = 'octoweb';
            octo.position.y = -octoHeight / 2;
            group.add(octo);
            group.parts.octoweb = octo;

            // 8. Stage 1 Plume
            const plumeS1 = createPlume(radius, height * 0.45, 'plumeS1');
            plumeS1.position.y = -octoHeight;
            group.add(plumeS1);
            group.parts.plumeS1 = plumeS1;
            
            return group;
        }

        function createDroneshipModel() {
            // ASDS: Droneship (Rectangle)
            const shipGroup = new THREE.Group();
            shipGroup.name = 'droneship';
            
            // Hull (larger scale for better visibility: was 0.06, 0.005, 0.03)
            const shipGeo = new THREE.BoxGeometry(0.1, 0.008, 0.05);
            const shipMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const ship = new THREE.Mesh(shipGeo, shipMat);
            shipGroup.add(ship);
            
            // Deck marking (Yellow Circle)
            const deckGeo = new THREE.CircleGeometry(0.02, 32);
            const deckMat = new THREE.MeshBasicMaterial({ color: 0xffcc00, side: THREE.DoubleSide });
            const deck = new THREE.Mesh(deckGeo, deckMat);
            deck.rotation.x = -Math.PI / 2;
            deck.position.y = 0.0042;
            shipGroup.add(deck);
            
            // "X" marking
            const xGeo = new THREE.PlaneGeometry(0.025, 0.005);
            const xMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const x1 = new THREE.Mesh(xGeo, xMat);
            x1.rotation.x = -Math.PI / 2;
            x1.rotation.z = Math.PI / 4;
            x1.position.y = 0.0044;
            shipGroup.add(x1);
            const x2 = x1.clone();
            x2.rotation.z = -Math.PI / 4;
            shipGroup.add(x2);

            return shipGroup;
        }

        function createLandingPadModel() {
            // RTLS: Landing Pad (Circle)
            const padGroup = new THREE.Group();
            padGroup.name = 'landingPad';

            const padGeo = new THREE.CircleGeometry(0.03, 32);
            const padMat = new THREE.MeshBasicMaterial({ 
                color: 0x444444, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide 
            });
            const pad = new THREE.Mesh(padGeo, padMat);
            padGroup.add(pad);
            
            // Outer ring
            const ringGeo = new THREE.RingGeometry(0.025, 0.028, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.z = 0.0001;
            padGroup.add(ring);
            
            // "X" center
            const xGeo = new THREE.PlaneGeometry(0.025, 0.004);
            const xMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const x1 = new THREE.Mesh(xGeo, xMat);
            x1.rotation.z = Math.PI / 4;
            x1.position.z = 0.0002;
            padGroup.add(x1);
            const x2 = x1.clone();
            x2.rotation.z = -Math.PI / 4;
            padGroup.add(x2);

            return padGroup;
        }

        function updateTrajectory(trajectoryData) {
            if (!renderer || !scene || !camera) {
                console.warn("updateTrajectory called before webgl components were ready");
                return;
            }
            // Remove existing trajectory group (which contains core and glow lines)
            if (trajectoryGroup) {
                if (globe) globe.remove(trajectoryGroup);
                scene.remove(trajectoryGroup);
                trajectoryGroup.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                trajectoryGroup = null;
                console.log("Removed existing trajectory group");
            }

            // Remove existing launch marker
            if (launchMarker) {
                if (globe) globe.remove(launchMarker);
                scene.remove(launchMarker);
                launchMarker.geometry.dispose();
                launchMarker.material.dispose();
                console.log("Removed existing launch marker");
            }

            if (!trajectoryData || !trajectoryData.trajectory || trajectoryData.trajectory.length < 2) {
                console.log("No valid trajectory data received:", trajectoryData);
                return;
            }

            console.log("Updating globe trajectory for mission:", trajectoryData.mission);
            console.log("Trajectory points:", trajectoryData.trajectory.length);
            console.log("Booster points:", trajectoryData.booster_trajectory ? trajectoryData.booster_trajectory.length : 0);
            console.log("Landing type:", trajectoryData.landing_type);

            try {
                __startTime = performance.now();
                activeCurves = []; // Reset active curves
                // Create trajectory points from the curved lat/lon data
                const points = [];

                trajectoryData.trajectory.forEach((point, index) => {
                    // Convert lat/lon to 3D coordinates on sphere
                    const phi = (90 - point.lat) * (Math.PI / 180);
                    const theta = (point.lon + 180) * (Math.PI / 180);

                    // Use the radius provided by the backend, or fallback to 1.012
                    const radius = (typeof point.r === 'number') ? point.r : 1.012;

                    const x = -(radius * Math.sin(phi) * Math.cos(theta));
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    const y = radius * Math.cos(phi);

                    points.push(new THREE.Vector3(x, y, z));
                });

                // Create color gradient for the trajectory
                // Modern, appealing gradient: Deep Blue -> White -> Hot Red for ascent
                const color1 = new THREE.Color(0x0000FF); // Deep Blue
                const color2 = new THREE.Color(0xFFFFFF); // White (hot core)
                const color3 = new THREE.Color(0xFF0000); // Hot Red

                trajectoryGroup = new THREE.Group();

                const t_sep = (trajectoryData.sep_idx && trajectoryData.trajectory.length > 1) 
                    ? (trajectoryData.sep_idx / (trajectoryData.trajectory.length - 1)) 
                    : 0.2; // Fallback to 20% if not provided

                // 1. Trace Core Line using TubeGeometry for thickness
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeRadius = 0.004; // Slightly thicker for visibility
                const radialSegments = 8;
                const tubularSegments = points.length * 6; // smoothness
                const tubeGeometry = new THREE.TubeGeometry(curve, tubularSegments, tubeRadius, radialSegments, false);

                // Apply vertex colors for gradient
                const count = tubeGeometry.attributes.position.count;
                const colorArray = new Float32Array(count * 3);
                const uvs = tubeGeometry.attributes.uv;

                for (let i = 0; i < count; i++) {
                    const u = uvs.getX(i); // 0 at start, 1 at end
                    let c;
                    if (u < 0.5) {
                        c = color1.clone().lerp(color2, u * 2);
                    } else {
                        c = color2.clone().lerp(color3, (u - 0.5) * 2);
                    }
                    colorArray[i * 3] = c.r;
                    colorArray[i * 3 + 1] = c.g;
                    colorArray[i * 3 + 2] = c.b;
                }

                tubeGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

                const tubeMaterial = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.95,
                    side: THREE.DoubleSide
                });
                const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tubeMesh.renderOrder = 1;
                // trajectoryGroup.add(tubeMesh); // Removed inner line, keep only glow

                // 2. Glow effect (larger tube, lower opacity, additive pulse)
                const glowRadius = 0.006; // Decreased and uniform size
                const glowGeometry = new THREE.TubeGeometry(curve, tubularSegments, glowRadius, radialSegments, false);
                glowGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3)); // reuse colors
                const glowMaterial = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false 
                });
                const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
                glowMesh.name = 'trajectoryGlow'; // For animation
                glowMesh.renderOrder = 2;
                trajectoryGroup.add(glowMesh);

                // 3. Moving rocket model at the head of the trajectory
                const flare = createFalcon9Model(false);
                
                flare.name = 'trajectoryFlare';
                trajectoryGroup.add(flare);
                activeCurves.push({ 
                    curve: curve, 
                    flare: flare, 
                    t_sep: t_sep,
                    isMain: true 
                });

                // 3. Booster Return Trajectory (Orange)
                if (trajectoryData.booster_trajectory && trajectoryData.booster_trajectory.length >= 2) {
                    console.log("Creating booster trajectory with", trajectoryData.booster_trajectory.length, "points");
                    const boosterPoints = [];
                    trajectoryData.booster_trajectory.forEach((point, index) => {
                        const phi = (90 - point.lat) * (Math.PI / 180);
                        const theta = (point.lon + 180) * (Math.PI / 180);

                        // Use radius from backend
                        const radius = (typeof point.r === 'number') ? point.r : 1.012;

                        const x = -(radius * Math.sin(phi) * Math.cos(theta));
                        const z = radius * Math.sin(phi) * Math.sin(theta);
                        const y = radius * Math.cos(phi);
                        boosterPoints.push(new THREE.Vector3(x, y, z));
                    });

                    const boosterCurve = new THREE.CatmullRomCurve3(boosterPoints);
                    const boosterTubeRadius = 0.005; // Thicker orange
                    const boosterTubeGeo = new THREE.TubeGeometry(boosterCurve, boosterPoints.length * 4, boosterTubeRadius, 8, false);

                    // Booster color gradient: Yellow -> Red
                    const boosterColor1 = new THREE.Color(0xFFFF00); // Yellow
                    const boosterColor2 = new THREE.Color(0xFF0000); // Red
                    const boosterCount = boosterTubeGeo.attributes.position.count;
                    const boosterColorArray = new Float32Array(boosterCount * 3);
                    const boosterUvs = boosterTubeGeo.attributes.uv;
                    for (let i = 0; i < boosterCount; i++) {
                        const u = boosterUvs.getX(i);
                        const c = boosterColor1.clone().lerp(boosterColor2, u);
                        boosterColorArray[i * 3] = c.r;
                        boosterColorArray[i * 3 + 1] = c.g;
                        boosterColorArray[i * 3 + 2] = c.b;
                    }
                    boosterTubeGeo.setAttribute('color', new THREE.BufferAttribute(boosterColorArray, 3));

                    const boosterMat = new THREE.MeshBasicMaterial({
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.85,
                        side: THREE.DoubleSide
                    });
                    const boosterMesh = new THREE.Mesh(boosterTubeGeo, boosterMat);
                    boosterMesh.renderOrder = 3; // Ensure it's rendered over the main trajectory if they overlap
                    // trajectoryGroup.add(boosterMesh); // Removed inner line, keep only glow

                    // Booster Glow
                    const boosterGlowRadius = 0.006; // Decreased and uniform size
                    const boosterGlowGeo = new THREE.TubeGeometry(boosterCurve, boosterPoints.length * 4, boosterGlowRadius, 8, false);
                    boosterGlowGeo.setAttribute('color', new THREE.BufferAttribute(boosterColorArray, 3)); // reuse colors
                    const boosterGlowMat = new THREE.MeshBasicMaterial({
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.4,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const boosterGlowMesh = new THREE.Mesh(boosterGlowGeo, boosterGlowMat);
                    boosterGlowMesh.renderOrder = 4;
                    trajectoryGroup.add(boosterGlowMesh);

                    // Moving rocket model for booster
                    const bFlare = createFalcon9Model(true);
                    trajectoryGroup.add(bFlare);
                    activeCurves.push({ 
                        curve: boosterCurve, 
                        flare: bFlare,
                        t_sep: t_sep,
                        isBooster: true
                    });


                }

                // Add trajectory group as a child of the globe
                if (globe) {
                    globe.add(trajectoryGroup);
                    console.log("Trajectory group added as child of globe");
                } else {
                    scene.add(trajectoryGroup);
                    console.log("Trajectory group added to scene (globe not available)");
                }

                // Removed launch site red dot marker per request; keep only the trajectory line

                // Remove previous orbit line/group if it exists
                if (window.currentOrbitLine) {
                    if (globe) globe.remove(window.currentOrbitLine);
                    scene.remove(window.currentOrbitLine);

                    // Safely dispose resources whether it's a Line or a Group
                    if (window.currentOrbitLine.traverse) {
                        window.currentOrbitLine.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) child.material.dispose();
                        });
                    } else {
                        // Fallback for simple meshes/lines
                        if (window.currentOrbitLine.geometry) window.currentOrbitLine.geometry.dispose();
                        if (window.currentOrbitLine.material) window.currentOrbitLine.material.dispose();
                    }

                    window.currentOrbitLine = null;
                    console.log("Removed existing orbit line/group");
                }

                // Draw orbital path if present
                if (trajectoryData.orbit_path && trajectoryData.orbit_path.length > 2) {
                    console.log("Rendering orbit path with", trajectoryData.orbit_path.length, "points");

                    const orbitPoints = [];
                    trajectoryData.orbit_path.forEach((point, index) => {
                        const phi = (90 - point.lat) * (Math.PI / 180);
                        const theta = (point.lon + 180) * (Math.PI / 180);
                        // Use radius from backend
                        const radius = (typeof point.r === 'number') ? point.r : 1.05;
                        const x = -(radius * Math.sin(phi) * Math.cos(theta));
                        const z = radius * Math.sin(phi) * Math.sin(theta);
                        const y = radius * Math.cos(phi);
                        orbitPoints.push(new THREE.Vector3(x, y, z));
                    });
                    // Use LineSegments for dashed effect
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);

                    // Create a group for the orbit to include a glow effect
                    const orbitGroup = new THREE.Group();

                    // 1. Core Orbit Line (Solid Red Tube)
                    // Create curve from points
                    const orbitCurve = new THREE.CatmullRomCurve3(orbitPoints);
                    // Close the curve if it loops? Usually orbit_path is a full loop segment, but let's leave open to match points.
                    orbitCurve.closed = true;

                    const orbitTubeRadius = 0.003;
                    const orbitSegments = orbitPoints.length * 6;

                    const orbitTubeGeo = new THREE.TubeGeometry(orbitCurve, orbitSegments, orbitTubeRadius, 8, true);
                    const orbitMat = new THREE.MeshBasicMaterial({
                        color: 0xFFFFFF, // White
                        transparent: true,
                        opacity: 0.9,
                        side: THREE.DoubleSide
                    });
                    const orbitMesh = new THREE.Mesh(orbitTubeGeo, orbitMat);
                    // orbitGroup.add(orbitMesh); // Removed inner line, keep only glow

                    // 2. Subtle Glow for Orbit
                    const orbitGlowRadius = 0.006; // Decreased and uniform size
                    const orbitGlowGeo = new THREE.TubeGeometry(orbitCurve, orbitSegments, orbitGlowRadius, 8, true);
                    const orbitGlowMat = new THREE.MeshBasicMaterial({
                        color: 0xFF0000, // Red
                        transparent: true,
                        opacity: 0.3,
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const orbitGlowMesh = new THREE.Mesh(orbitGlowGeo, orbitGlowMat);
                    orbitGroup.add(orbitGlowMesh);

                    if (globe) {
                        globe.add(orbitGroup);
                    } else {
                        scene.add(orbitGroup);
                    }
                    window.currentOrbitLine = orbitGroup;
                    console.log("Orbit group added with glow");
                }

                // 4. Landing Site Marker (Droneship or Pad)
                if (trajectoryData.landing_site_coords) {
                    const lPos = trajectoryData.landing_site_coords;
                    const phi = (90 - lPos.lat) * (Math.PI / 180);
                    const theta = (lPos.lon + 180) * (Math.PI / 180);
                    const radius = 1.002; // Slightly higher for visibility
                    
                    const x = -(radius * Math.sin(phi) * Math.cos(theta));
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    const y = radius * Math.cos(phi);
                    
                    const markerPos = new THREE.Vector3(x, y, z);
                    
                    if (trajectoryData.is_asds) {
                        const shipGroup = createDroneshipModel();
                        shipGroup.position.copy(markerPos);
                        shipGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), markerPos.clone().normalize());
                        trajectoryGroup.add(shipGroup);
                        console.log("Added mission-specific droneship marker");
                    } else {
                        const padGroup = createLandingPadModel();
                        padGroup.position.copy(markerPos);
                        padGroup.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), markerPos.clone().normalize());
                        trajectoryGroup.add(padGroup);
                        console.log("Added mission-specific landing pad marker");
                    }
                }

                // Force a render
                renderer.render(scene, camera);
                console.log("Forced render");

                // Auto-center view on the launch site (trajectory start)
                // "Slightly left of center" means we center the camera on a longitude slightly East of the launch site.
                if (trajectoryData.trajectory.length > 0) {
                    const startLon = trajectoryData.trajectory[0].lon;
                    // Calibration: roughly 4.7 rad is Lon 0 (Africa). Increasing rotation moves view West (decreasing Lon center).
                    // Formula: rotY = 4.7 - (TargetLon * PI/180)
                    // We want CenterLon = StartLon + 25 degrees (so point is 25 deg left/West of center)
                    const offsetDeg = 25;
                    const targetLon = startLon + offsetDeg;
                    const targetRot = 4.7 - (targetLon * (Math.PI / 180));

                    // Normalize to 0..2PI just to be clean, though not strictly required
                    globe.rotation.y = targetRot % (2 * Math.PI);
                    console.log(`Auto-rotated to ${globe.rotation.y.toFixed(2)} rad for start lon ${startLon}`);
                }

            } catch (error) {
                console.error("Error in updateTrajectory:", error);
            }
        }
        // Expose function to window as early as possible
        window.updateTrajectory = updateTrajectory;

        // Initialize and start animation, but ensure THREE is available first
        console.log("Starting initialization (waiting for THREE if offline)...");
        if (window.__ensureThreeAndBoot) {
            window.__ensureThreeAndBoot(function () {
                try { init(); } catch (e) { console.error('Init failed, will retry shortly:', e); setTimeout(function () { window.__ensureThreeAndBoot(init); }, 4000); }
            });
        } else {
            // Fallback: try to init directly
            try { init(); } catch (e) { console.error('Init failed before loader available:', e); }
        }

        // Expose functions to Qt

        // If we were offline at start, try to add clouds when we come online
        window.addEventListener('online', function () {
            try {
                if (!globe) return;
                const clouds = globe.getObjectByName('clouds');
                if (clouds && cloudUniforms && !cloudUniforms.hasTexture.value) {
                    console.log('Attempting to load cloud texture now that we are online...');
                    if (typeof loadCloudTextureFunc === 'function') {
                        loadCloudTextureFunc();
                    }
                }
            } catch (e) {
                console.warn('Failed to add clouds after going online:', e);
            }
        });

        // Make globe interactive
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            userInteracting = true;
            isInMomentum = false; // Stop momentum when user takes control
            momentumX = 0;
            momentumY = 0;
            lastTime = Date.now();
            previousMousePosition = { x: event.clientX, y: event.clientY };
            touchMode = 'drag';
            cumulativeDragDistance = 0;
            hadPinchSinceLastDrag = false;
            resetRecentMoves();
        });

        document.addEventListener('mousemove', (event) => {
            if (!isMouseDown) return;

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            cumulativeDragDistance += Math.hypot(deltaX, deltaY);

            // Adjust y-rotation direction based on globe orientation to prevent reversal when upside down
            const yDirection = Math.cos(globe.rotation.x) > 0 ? 1 : -1;

            // Track velocity for momentum (bake in current orientation)
            if (deltaTime > 0) {
                momentumX = (deltaX * yDirection) / deltaTime * 0.1; // Scale for smooth momentum
                momentumY = (deltaY) / deltaTime * 0.1;
                lastDeltaX = deltaX; lastDeltaY = deltaY; lastMoveTimeMs = currentTime;
                pushRecentMove(deltaX, deltaY, yDirection, deltaTime, currentTime);
            }

            globe.rotation.y += deltaX * 0.005 * yDirection;
            if (!window.__userRotOffset) window.__userRotOffset = 0;
            window.__userRotOffset += deltaX * 0.005 * yDirection;
            globe.rotation.x += deltaY * 0.005;
            clampRotationX();

            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        function shouldStartMomentum() {
            const now = Date.now();
            const recent = (now - lastMoveTimeMs) < RECENT_MS_THRESHOLD;
            const movedEnough = cumulativeDragDistance > DRAG_DEADZONE_PX;
            const { vx, vy, mag } = getAveragedVelocity();
            return (
                touchMode === 'drag' &&
                !hadPinchSinceLastDrag &&
                recent &&
                movedEnough &&
                mag > MIN_RELEASE_VELOCITY
            );
        }

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
            const start = shouldStartMomentum();
            if (start) {
                const v = getAveragedVelocity();
                momentumX = v.vx; momentumY = v.vy;
            }
            isInMomentum = start;
            if (!isInMomentum) { momentumX = 0; momentumY = 0; }
            touchMode = 'none';
            resetRecentMoves();
            // Mouse up ends direct interaction; momentum may continue but that's not a touch
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });

        // Touch support for mobile
        document.addEventListener('touchstart', (event) => {
            if (event.touches.length === 1) {
                isMouseDown = true;
                userInteracting = true;
                isInMomentum = false; // Stop momentum when user takes control
                momentumX = 0;
                momentumY = 0;
                lastTime = Date.now();
                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
                touchMode = 'drag';
                cumulativeDragDistance = 0;
                // Do not reset hadPinchSinceLastDrag here (pinch may have preceded)
                resetRecentMoves();
            } else if (event.touches.length >= 2) {
                // Transition into pinch mode
                touchMode = 'pinch';
                isMouseDown = false;
                isInMomentum = false;
                momentumX = 0; momentumY = 0;
                hadPinchSinceLastDrag = true; // ensure no inertia on release after any pinch
                resetRecentMoves();
                userInteracting = true;
            }
        });

        document.addEventListener('touchmove', (event) => {
            if (!isMouseDown || event.touches.length !== 1) return;

            event.preventDefault();

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;
            cumulativeDragDistance += Math.hypot(deltaX, deltaY);

            // Adjust y-rotation direction based on globe orientation to prevent reversal when upside down
            const yDirection = Math.cos(globe.rotation.x) > 0 ? 1 : -1;

            // Track velocity for momentum (bake in current orientation)
            if (deltaTime > 0) {
                momentumX = (deltaX * yDirection) / deltaTime * 0.1;
                momentumY = (deltaY) / deltaTime * 0.1;
                lastDeltaX = deltaX; lastDeltaY = deltaY; lastMoveTimeMs = currentTime;
                pushRecentMove(deltaX, deltaY, yDirection, deltaTime, currentTime);
            }

            globe.rotation.y += deltaX * 0.005 * yDirection;
            if (!window.__userRotOffset) window.__userRotOffset = 0;
            window.__userRotOffset += deltaX * 0.005 * yDirection;
            globe.rotation.x += deltaY * 0.005;
            clampRotationX();

            previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }, { passive: false });

        function endTouchCommon() {
            // Only start momentum if we were dragging, not pinching, and had a recent move
            isMouseDown = false;
            const start = shouldStartMomentum();
            if (start) {
                const v = getAveragedVelocity();
                momentumX = v.vx; momentumY = v.vy;
            }
            isInMomentum = start;
            if (!isInMomentum) { momentumX = 0; momentumY = 0; }
            // Reset mode when all touches are gone
            touchMode = 'none';
            hadPinchSinceLastDrag = false; // reset after gesture fully ends
            resetRecentMoves();
        }

        document.addEventListener('touchend', (e) => {
            // If there are still touches, don't finalize drag end here (multi-touch transition)
            if (e.touches && e.touches.length > 0) return;
            endTouchCommon();
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });

        document.addEventListener('touchcancel', () => {
            endTouchCommon();
            userInteracting = false;
            if (pendingSystemResume) { systemPaused = false; isAutoRotatePaused = (userPaused || systemPaused); pendingSystemResume = false; }
        });


        // Provide guarded hooks for external callers (Qt) to control spin/animation.
        // These respect active user interaction and will resume deterministically.
        window.clearInteraction = function () {
            try { if (window.globeAutospinGuard) console.log('[globe] clearInteraction()'); } catch (e) { }
            activePointers = 0;
            userInteracting = false;
            isInMomentum = false;
            momentumX = 0; momentumY = 0;
            touchMode = 'none';
            resetRecentMoves();
        };
        window.resumeSpin = function () {
            if (userInteracting) { pendingSystemResume = true; return; }
            systemPaused = false;
            autoSpinEnabled = true;
            if (controls && typeof controls.autoRotate === 'boolean') controls.autoRotate = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            try { if (window.globeAutospinGuard) console.log('[globe] resumeSpin invoked'); } catch (e) { }
        };
        window.forceResumeSpin = function () {
            window.clearInteraction();
            systemPaused = false;
            autoSpinEnabled = true;
            if (controls && typeof controls.autoRotate === 'boolean') controls.autoRotate = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            pendingSystemResume = false;
            try { if (window.globeAutospinGuard) console.log('[globe] forceResumeSpin invoked'); } catch (e) { }
        };
        window.pauseSpin = function () {
            systemPaused = true;
            isAutoRotatePaused = (userPaused || systemPaused);
            try { if (window.globeAutospinGuard) console.log('[globe] pauseSpin invoked'); } catch (e) { }
        };
        window.startSpin = function () { if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };
        window.resumeAnimation = function () { if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };
        window.startAnimation = function () { if (userInteracting) { pendingSystemResume = true; return; } systemPaused = false; autoSpinEnabled = true; isAutoRotatePaused = (userPaused || systemPaused); };

        // Handle window focus/visibility to avoid "stuck interaction" states and auto-resume when appropriate
        window.addEventListener('blur', function () {
            if (window.globeAutospinGuard) {
                window.clearInteraction();
            }
        });
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                if (window.globeAutospinGuard) {
                    window.clearInteraction();
                    // If we were pending a resume, complete it now
                    if (pendingSystemResume) { pendingSystemResume = false; systemPaused = false; autoSpinEnabled = true; }
                }
            }
        });

        // Inactivity fallback: if marked interacting but no activity and no pointers, clear it
        setInterval(function () {
            try {
                if (!window.globeAutospinGuard) return;
                const now = Date.now();
                if (userInteracting && activePointers === 0 && (now - lastMoveTimeMs) > 1500) {
                    console.log('[globe] clearing stale interaction due to inactivity');
                    window.clearInteraction();
                }
            } catch (e) { }
        }, 1000);

        // Visibility instrumentation
        document.addEventListener('visibilitychange', function () {
            try { console.log('[globe] visibilitychange:', document.visibilityState); } catch (e) { }
            if (document.visibilityState === 'visible') {
                // When page becomes visible, allow a small grace then resume if allowed
                setTimeout(function () {
                    if (!userPaused && window.globeAutospinGuard !== false) {
                        window.resumeSpin();
                    }
                }, 250);
            }
        });

        // Self-healing watchdog: if frames stop for >3s while visible, resume
        (function () {
            const CHECK_MS = 1000;
            const STALL_MS = 3000;
            setInterval(function () {
                if (typeof document === 'undefined') return;
                if (document.visibilityState !== 'visible') return;
                if (window.globeAutospinGuard === false) return;
                const now = performance.now();
                if (now - __lastRenderTs > STALL_MS) {
                    try { console.log('[globe] watchdog: render stalled, attempting resume'); } catch (e) { }
                    window.resumeSpin();
                }
            }, CHECK_MS);
        })();

        // Play/Pause button functionality
        // Play/Pause button functionality
        document.getElementById('playPauseBtn').addEventListener('click', () => {
            userPaused = !userPaused;
            isAutoRotatePaused = (userPaused || systemPaused);

            // "Actually works": If paused, kill any active momentum immediately
            if (userPaused) {
                isInMomentum = false;
                momentumX = 0;
                momentumY = 0;
            }

            const button = document.getElementById('playPauseBtn');
            const icon = button.querySelector('i');
            if (isAutoRotatePaused) {
                icon.className = 'fas fa-play';
            } else {
                icon.className = 'fas fa-pause';
            }
        });

        // Initial instrumentation
        try { console.log('[globe] script loaded; awaiting boot'); } catch (e) { }

        // Theme handling
        window.setTheme = function (theme) {
            try { console.log('[globe] setTheme:', theme); } catch (e) { }
            if (theme === 'light') {
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
            }
        };
    </script>
</body>

</html>

